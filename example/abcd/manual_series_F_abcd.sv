
//This file should be called F_abcd.sv
//This is autogenerated code. Edit by hand at your peril!!!

//Warning: This is experimental manual_series composition code.


	module F_combinatorialVerilog_abcd_policy_ab_input (
		
		//inputs (plant to controller)
		input wire  A_ptc_in,
		
		// Internal Variables Input
		
		
		//helpful state output input var
		input wire  abcd_policy_ab_state_in,
		
		// Recovery Reference
		output wire  abcd_policy_ab_input_recovery_ref,

		input wire clk
		);

		//For each policy, we need define types for the state machines
		localparam
			POLICY_STATE_abcd_ab_b0 = 0,
			POLICY_STATE_abcd_ab_violation = 1;

		
		reg A = 0;
		
		// Recovery ref declare and init
		reg  recoveryReference = 0;

		initial begin
			recoveryReference = 0;
		end

		always @(abcd_policy_ab_state_in, A_ptc_in, clk) begin
			
			// Default no change to inputs (transparency) 
			A = A_ptc_in;
			
			recoveryReference = 0;

			//input policies
			
				//INPUT POLICY ab BEGIN 
				case(abcd_policy_ab_state_in)
					POLICY_STATE_abcd_ab_b0: begin
						// Default location recovery reference
						
						
						if (((((((A || A) || A) || A) || !(A)) || !(A)) || !(A)) || !(A)) begin
							//transition b0 -> violation on A or A or A or A or not (A) or not (A) or not (A) or not (A)
							//select a transition to solve the problem
							
							//Selected non-violation transition "b0 -> b0 on not (A) or A" and action was not required
							
							// Set recovery reference
							recoveryReference = 0;
						end
					end
					
				endcase
			
			//INPUT POLICY ab END
		end
		assign abcd_policy_ab_input_recovery_ref = recoveryReference;

	endmodule

	module F_combinatorialVerilog_abcd_policy_ab_output (
		//(Final) inputs (plant to controller)
		input wire  A_ptc_out,
		


		//outputs (controller to plant)
		input wire  B_ctp_in,
		//output wire  B_ctp_out,
		
		input wire  C_ctp_in,
		//output wire  C_ctp_out,
		
		input wire  D_ctp_in,
		//output wire  D_ctp_out,
		

		// Internal Variables Input
		

		// State Input
		input wire  abcd_policy_ab_state_in,

		// Recovery Reference Output
		output wire  abcd_policy_ab_output_recovery_ref,

		input wire clk

	);

		//For each policy, we need define types for the state machines
		localparam
			POLICY_STATE_abcd_ab_b0 = 0,
			POLICY_STATE_abcd_ab_violation = 1;

		
		reg A = 0;
		
		reg B = 0;
		
		reg C = 0;
		
		reg D = 0;
		
		// Recovery ref declare and init
		reg  recoveryReference = 0;

		initial begin
			recoveryReference = 0;
		end

		always @(abcd_policy_ab_state_in, B_ctp_in,C_ctp_in,D_ctp_in, clk) begin
			// Default no change to inputs/outputs (transparency) 
			A = A_ptc_out;
			
			B = B_ctp_in;
			C = C_ctp_in;
			D = D_ctp_in;
			
			recoveryReference = 0;

			//output policies
				//OUTPUT POLICY ab BEGIN 
				
				case(abcd_policy_ab_state_in)
					POLICY_STATE_abcd_ab_b0: begin
						// Default location recovery reference
						
						
						if ((((((((((A && !(B)) && C) && D) || (((A && !(B)) && !(C)) && D)) || (((A && !(B)) && C) && !(D))) || (((A && !(B)) && !(C)) && !(D))) || (((!(A) && B) && C) && D)) || (((!(A) && B) && !(C)) && D)) || (((!(A) && B) && C) && !(D))) || (((!(A) && B) && !(C)) && !(D))) begin
							//transition b0 -> violation on ( A and !B and C and D ) or ( A and !B and !C and D ) or ( A and !B and C and !D ) or ( A and !B and !C and !D ) or ( !A and B and C and D ) or ( !A and B and !C and D ) or ( !A and B and C and !D ) or ( !A and B and !C and !D )
							//select a transition to solve the problem
							
							//Selected non-violation transition "b0 -> b0 on ( !A and !B ) or ( A and B )" and action was not required
							
							// Set recovery reference
							recoveryReference = 0;

						end 
					end
					
				endcase
			
			//OUTPUT POLICY ab END
		end

		assign abcd_policy_ab_output_recovery_ref = recoveryReference;

	endmodule

	module F_combinatorialVerilog_abcd_policy_ab_transition (
		// Final inputs (plant to controller) 
		input wire A_ptc_final,
		
		// Final outputs (controller to plant) 
		input wire B_ctp_final,
		
		input wire C_ctp_final,
		
		input wire D_ctp_final,
		

		// Internal Variables Output
		

		// State Output
		output wire  abcd_policy_ab_state_out,

		input wire clk
		);
		
		//For each policy, we need define types for the state machines
		localparam
			POLICY_STATE_abcd_ab_b0 = 0,
			POLICY_STATE_abcd_ab_violation = 1;
		
		// Maybe remove these? 
		reg A = 0;
		
		reg B = 0;
		
		reg C = 0;
		
		reg D = 0;
		
		//internal vars
		

		//For each policy, we need a reg for the state machine
		reg  abcd_policy_ab_c_state = 0;
		reg  abcd_policy_ab_n_state = 0;

		initial begin
			abcd_policy_ab_c_state = 0;
			abcd_policy_ab_n_state = 0;
		end

		always @(posedge clk)
		begin
			abcd_policy_ab_c_state = abcd_policy_ab_n_state;

			//increment timers/clocks
			//internal vars
			
		end

		always @* begin
			
			A = A_ptc_final; 
			
			B = B_ctp_final; 
			C = C_ctp_final; 
			D = D_ctp_final; 

			// Default no location change
			abcd_policy_ab_n_state = abcd_policy_ab_c_state;
			
			// Default no clock reset
			

			//transTaken_abcd_policy_ab = 0;
			//select transition to advance state
			case(abcd_policy_ab_c_state)
				POLICY_STATE_abcd_ab_b0: begin
					
					 if ((!(A) && !(B)) || (A && B)) begin
						//transition b0 -> b0 on ( !A and !B ) or ( A and B )
						abcd_policy_ab_n_state = POLICY_STATE_abcd_ab_b0;
						//set expressions
						
						//transTaken_abcd_policy_ab = 1;
					end  
					else if ((((((((((A && !(B)) && C) && D) || (((A && !(B)) && !(C)) && D)) || (((A && !(B)) && C) && !(D))) || (((A && !(B)) && !(C)) && !(D))) || (((!(A) && B) && C) && D)) || (((!(A) && B) && !(C)) && D)) || (((!(A) && B) && C) && !(D))) || (((!(A) && B) && !(C)) && !(D))) begin
						//transition b0 -> violation on ( A and !B and C and D ) or ( A and !B and !C and D ) or ( A and !B and C and !D ) or ( A and !B and !C and !D ) or ( !A and B and C and D ) or ( !A and B and !C and D ) or ( !A and B and C and !D ) or ( !A and B and !C and !D )
						abcd_policy_ab_n_state = POLICY_STATE_abcd_ab_violation;
						//set expressions
						
						//transTaken_abcd_policy_ab = 1;
					end   else begin
						//only possible in a violation
						abcd_policy_ab_n_state = POLICY_STATE_abcd_ab_violation;
						//transTaken_abcd_policy_ab = 1;
					end
				end
				
				default begin
					//if we are here, we're in the violation state
					//the violation state permanently stays in violation
					abcd_policy_ab_n_state = POLICY_STATE_abcd_ab_violation;
					//transTaken_abcd_policy_ab = 1;
				end
			endcase

		end

		//emit state/time inputs
		assign abcd_policy_ab_state_out =  abcd_policy_ab_c_state;
		//internal vars
		

	endmodule

	
	module F_combinatorialVerilog_abcd_policy_ac_input (
		
		//inputs (plant to controller)
		input wire  A_ptc_in,
		
		// Internal Variables Input
		
		
		//helpful state output input var,
		
		input wire  abcd_policy_ac_state_in,
		
		// Recovery Reference
		output wire  abcd_policy_ac_input_recovery_ref,

		input wire clk
		);

		//For each policy, we need define types for the state machines
		localparam
			POLICY_STATE_abcd_ac_c0 = 0,
			POLICY_STATE_abcd_ac_violation = 1;

		
		reg A = 0;
		
		// Recovery ref declare and init
		reg  recoveryReference = 0;

		initial begin
			recoveryReference = 0;
		end

		always @(abcd_policy_ac_state_in, A_ptc_in, clk) begin
			
			// Default no change to inputs (transparency) 
			A = A_ptc_in;
			
			recoveryReference = 0;

			//input policies
			
				//INPUT POLICY ac BEGIN 
				case(abcd_policy_ac_state_in)
					POLICY_STATE_abcd_ac_c0: begin
						// Default location recovery reference
						
						
						if (((((((A || A) || A) || A) || !(A)) || !(A)) || !(A)) || !(A)) begin
							//transition c0 -> violation on A or A or A or A or not (A) or not (A) or not (A) or not (A)
							//select a transition to solve the problem
							
							//Selected non-violation transition "c0 -> c0 on not (A) or A" and action was not required
							
							// Set recovery reference
							recoveryReference = 0;
						end
					end
					
				endcase
			
			//INPUT POLICY ac END
		end
		assign abcd_policy_ac_input_recovery_ref = recoveryReference;

	endmodule

	module F_combinatorialVerilog_abcd_policy_ac_output (
		//(Final) inputs (plant to controller)
		input wire  A_ptc_out,
		


		//outputs (controller to plant)
		input wire  B_ctp_in,
		//output wire  B_ctp_out,
		
		input wire  C_ctp_in,
		//output wire  C_ctp_out,
		
		input wire  D_ctp_in,
		//output wire  D_ctp_out,
		

		// Internal Variables Input
		

		// State Input
		input wire  abcd_policy_ac_state_in,

		// Recovery Reference Output
		output wire  abcd_policy_ac_output_recovery_ref,

		input wire clk

	);

		//For each policy, we need define types for the state machines
		localparam
			POLICY_STATE_abcd_ac_c0 = 0,
			POLICY_STATE_abcd_ac_violation = 1;

		
		reg A = 0;
		
		reg B = 0;
		
		reg C = 0;
		
		reg D = 0;
		
		// Recovery ref declare and init
		reg  recoveryReference = 0;

		initial begin
			recoveryReference = 0;
		end

		always @(abcd_policy_ac_state_in, B_ctp_in,C_ctp_in,D_ctp_in, clk) begin
			// Default no change to inputs/outputs (transparency) 
			A = A_ptc_out;
			
			B = B_ctp_in;
			C = C_ctp_in;
			D = D_ctp_in;
			
			recoveryReference = 0;

			//output policies
				//OUTPUT POLICY ac BEGIN 
				
				case(abcd_policy_ac_state_in)
					POLICY_STATE_abcd_ac_c0: begin
						// Default location recovery reference
						
						
						if ((((((((((A && !(C)) && B) && D) || (((A && !(C)) && !(B)) && D)) || (((A && !(C)) && B) && !(D))) || (((A && !(C)) && !(B)) && !(D))) || (((!(A) && C) && B) && D)) || (((!(A) && C) && !(B)) && D)) || (((!(A) && C) && B) && !(D))) || (((!(A) && C) && !(B)) && !(D))) begin
							//transition c0 -> violation on ( A and !C and B and D ) or ( A and !C and !B and D ) or ( A and !C and B and !D ) or ( A and !C and !B and !D ) or ( !A and C and B and D ) or ( !A and C and !B and D ) or ( !A and C and B and !D ) or ( !A and C and !B and !D )
							//select a transition to solve the problem
							
							//Selected non-violation transition "c0 -> c0 on ( !A and !C ) or ( A and C )" and action was not required
							
							// Set recovery reference
							recoveryReference = 0;

						end 
					end
					
				endcase
			
			//OUTPUT POLICY ac END
		end

		assign abcd_policy_ac_output_recovery_ref = recoveryReference;

	endmodule

	module F_combinatorialVerilog_abcd_policy_ac_transition (
		// Final inputs (plant to controller) 
		input wire A_ptc_final,
		
		// Final outputs (controller to plant) 
		input wire B_ctp_final,
		
		input wire C_ctp_final,
		
		input wire D_ctp_final,
		

		// Internal Variables Output
		

		// State Output
		output wire  abcd_policy_ac_state_out,

		input wire clk
		);
		
		//For each policy, we need define types for the state machines
		localparam
			POLICY_STATE_abcd_ac_c0 = 0,
			POLICY_STATE_abcd_ac_violation = 1;
		
		// Maybe remove these? 
		reg A = 0;
		
		reg B = 0;
		
		reg C = 0;
		
		reg D = 0;
		
		//internal vars
		

		//For each policy, we need a reg for the state machine
		reg  abcd_policy_ac_c_state = 0;
		reg  abcd_policy_ac_n_state = 0;

		initial begin
			abcd_policy_ac_c_state = 0;
			abcd_policy_ac_n_state = 0;
		end

		always @(posedge clk)
		begin
			abcd_policy_ac_c_state = abcd_policy_ac_n_state;

			//increment timers/clocks
			//internal vars
			
		end

		always @* begin
			
			A = A_ptc_final; 
			
			B = B_ctp_final; 
			C = C_ctp_final; 
			D = D_ctp_final; 

			// Default no location change
			abcd_policy_ac_n_state = abcd_policy_ac_c_state;
			
			// Default no clock reset
			

			//transTaken_abcd_policy_ac = 0;
			//select transition to advance state
			case(abcd_policy_ac_c_state)
				POLICY_STATE_abcd_ac_c0: begin
					
					 if ((!(A) && !(C)) || (A && C)) begin
						//transition c0 -> c0 on ( !A and !C ) or ( A and C )
						abcd_policy_ac_n_state = POLICY_STATE_abcd_ac_c0;
						//set expressions
						
						//transTaken_abcd_policy_ac = 1;
					end  
					else if ((((((((((A && !(C)) && B) && D) || (((A && !(C)) && !(B)) && D)) || (((A && !(C)) && B) && !(D))) || (((A && !(C)) && !(B)) && !(D))) || (((!(A) && C) && B) && D)) || (((!(A) && C) && !(B)) && D)) || (((!(A) && C) && B) && !(D))) || (((!(A) && C) && !(B)) && !(D))) begin
						//transition c0 -> violation on ( A and !C and B and D ) or ( A and !C and !B and D ) or ( A and !C and B and !D ) or ( A and !C and !B and !D ) or ( !A and C and B and D ) or ( !A and C and !B and D ) or ( !A and C and B and !D ) or ( !A and C and !B and !D )
						abcd_policy_ac_n_state = POLICY_STATE_abcd_ac_violation;
						//set expressions
						
						//transTaken_abcd_policy_ac = 1;
					end   else begin
						//only possible in a violation
						abcd_policy_ac_n_state = POLICY_STATE_abcd_ac_violation;
						//transTaken_abcd_policy_ac = 1;
					end
				end
				
				default begin
					//if we are here, we're in the violation state
					//the violation state permanently stays in violation
					abcd_policy_ac_n_state = POLICY_STATE_abcd_ac_violation;
					//transTaken_abcd_policy_ac = 1;
				end
			endcase

		end

		//emit state/time inputs
		assign abcd_policy_ac_state_out =  abcd_policy_ac_c_state;
		//internal vars
		

	endmodule

	
	module F_combinatorialVerilog_abcd_policy_ad_input (
		
		//inputs (plant to controller)
		input wire  A_ptc_in,
		
		// Internal Variables Input
		
		
		//helpful state output input var,
		
		input wire  abcd_policy_ad_state_in,
		
		// Recovery Reference
		output wire  abcd_policy_ad_input_recovery_ref,

		input wire clk
		);

		//For each policy, we need define types for the state machines
		localparam
			POLICY_STATE_abcd_ad_d0 = 0,
			POLICY_STATE_abcd_ad_violation = 1;

		
		reg A = 0;
		
		// Recovery ref declare and init
		reg  recoveryReference = 0;

		initial begin
			recoveryReference = 0;
		end

		always @(abcd_policy_ad_state_in, A_ptc_in, clk) begin
			
			// Default no change to inputs (transparency) 
			A = A_ptc_in;
			
			recoveryReference = 0;

			//input policies
			
				//INPUT POLICY ad BEGIN 
				case(abcd_policy_ad_state_in)
					POLICY_STATE_abcd_ad_d0: begin
						// Default location recovery reference
						
						
						if (((((((A || A) || A) || A) || !(A)) || !(A)) || !(A)) || !(A)) begin
							//transition d0 -> violation on A or A or A or A or not (A) or not (A) or not (A) or not (A)
							//select a transition to solve the problem
							
							//Selected non-violation transition "d0 -> d0 on not (A) or A" and action was not required
							
							// Set recovery reference
							recoveryReference = 0;
						end
					end
					
				endcase
			
			//INPUT POLICY ad END
		end
		assign abcd_policy_ad_input_recovery_ref = recoveryReference;

	endmodule

	module F_combinatorialVerilog_abcd_policy_ad_output (
		//(Final) inputs (plant to controller)
		input wire  A_ptc_out,
		


		//outputs (controller to plant)
		input wire  B_ctp_in,
		//output wire  B_ctp_out,
		
		input wire  C_ctp_in,
		//output wire  C_ctp_out,
		
		input wire  D_ctp_in,
		//output wire  D_ctp_out,
		

		// Internal Variables Input
		

		// State Input
		input wire  abcd_policy_ad_state_in,

		// Recovery Reference Output
		output wire  abcd_policy_ad_output_recovery_ref,

		input wire clk

	);

		//For each policy, we need define types for the state machines
		localparam
			POLICY_STATE_abcd_ad_d0 = 0,
			POLICY_STATE_abcd_ad_violation = 1;

		
		reg A = 0;
		
		reg B = 0;
		
		reg C = 0;
		
		reg D = 0;
		
		// Recovery ref declare and init
		reg  recoveryReference = 0;

		initial begin
			recoveryReference = 0;
		end

		always @(abcd_policy_ad_state_in, B_ctp_in,C_ctp_in,D_ctp_in, clk) begin
			// Default no change to inputs/outputs (transparency) 
			A = A_ptc_out;
			
			B = B_ctp_in;
			C = C_ctp_in;
			D = D_ctp_in;
			
			recoveryReference = 0;

			//output policies
				//OUTPUT POLICY ad BEGIN 
				
				case(abcd_policy_ad_state_in)
					POLICY_STATE_abcd_ad_d0: begin
						// Default location recovery reference
						
						
						if ((((((((((A && !(D)) && B) && C) || (((A && !(D)) && !(B)) && C)) || (((A && !(D)) && B) && !(C))) || (((A && !(D)) && !(B)) && !(C))) || (((!(A) && D) && B) && C)) || (((!(A) && D) && !(B)) && C)) || (((!(A) && D) && B) && !(C))) || (((!(A) && D) && !(B)) && !(C))) begin
							//transition d0 -> violation on ( A and !D and B and C ) or ( A and !D and !B and C ) or ( A and !D and B and !C ) or ( A and !D and !B and !C ) or ( !A and D and B and C ) or ( !A and D and !B and C ) or ( !A and D and B and !C ) or ( !A and D and !B and !C )
							//select a transition to solve the problem
							
							//Selected non-violation transition "d0 -> d0 on ( !A and !D ) or ( A and D )" and action was not required
							
							// Set recovery reference
							recoveryReference = 0;

						end 
					end
					
				endcase
			
			//OUTPUT POLICY ad END
		end

		assign abcd_policy_ad_output_recovery_ref = recoveryReference;

	endmodule

	module F_combinatorialVerilog_abcd_policy_ad_transition (
		// Final inputs (plant to controller) 
		input wire A_ptc_final,
		
		// Final outputs (controller to plant) 
		input wire B_ctp_final,
		
		input wire C_ctp_final,
		
		input wire D_ctp_final,
		

		// Internal Variables Output
		

		// State Output
		output wire  abcd_policy_ad_state_out,

		input wire clk
		);
		
		//For each policy, we need define types for the state machines
		localparam
			POLICY_STATE_abcd_ad_d0 = 0,
			POLICY_STATE_abcd_ad_violation = 1;
		
		// Maybe remove these? 
		reg A = 0;
		
		reg B = 0;
		
		reg C = 0;
		
		reg D = 0;
		
		//internal vars
		

		//For each policy, we need a reg for the state machine
		reg  abcd_policy_ad_c_state = 0;
		reg  abcd_policy_ad_n_state = 0;

		initial begin
			abcd_policy_ad_c_state = 0;
			abcd_policy_ad_n_state = 0;
		end

		always @(posedge clk)
		begin
			abcd_policy_ad_c_state = abcd_policy_ad_n_state;

			//increment timers/clocks
			//internal vars
			
		end

		always @* begin
			
			A = A_ptc_final; 
			
			B = B_ctp_final; 
			C = C_ctp_final; 
			D = D_ctp_final; 

			// Default no location change
			abcd_policy_ad_n_state = abcd_policy_ad_c_state;
			
			// Default no clock reset
			

			//transTaken_abcd_policy_ad = 0;
			//select transition to advance state
			case(abcd_policy_ad_c_state)
				POLICY_STATE_abcd_ad_d0: begin
					
					 if ((!(A) && !(D)) || (A && D)) begin
						//transition d0 -> d0 on ( !A and !D ) or ( A and D )
						abcd_policy_ad_n_state = POLICY_STATE_abcd_ad_d0;
						//set expressions
						
						//transTaken_abcd_policy_ad = 1;
					end  
					else if ((((((((((A && !(D)) && B) && C) || (((A && !(D)) && !(B)) && C)) || (((A && !(D)) && B) && !(C))) || (((A && !(D)) && !(B)) && !(C))) || (((!(A) && D) && B) && C)) || (((!(A) && D) && !(B)) && C)) || (((!(A) && D) && B) && !(C))) || (((!(A) && D) && !(B)) && !(C))) begin
						//transition d0 -> violation on ( A and !D and B and C ) or ( A and !D and !B and C ) or ( A and !D and B and !C ) or ( A and !D and !B and !C ) or ( !A and D and B and C ) or ( !A and D and !B and C ) or ( !A and D and B and !C ) or ( !A and D and !B and !C )
						abcd_policy_ad_n_state = POLICY_STATE_abcd_ad_violation;
						//set expressions
						
						//transTaken_abcd_policy_ad = 1;
					end   else begin
						//only possible in a violation
						abcd_policy_ad_n_state = POLICY_STATE_abcd_ad_violation;
						//transTaken_abcd_policy_ad = 1;
					end
				end
				
				default begin
					//if we are here, we're in the violation state
					//the violation state permanently stays in violation
					abcd_policy_ad_n_state = POLICY_STATE_abcd_ad_violation;
					//transTaken_abcd_policy_ad = 1;
				end
			endcase

		end

		//emit state/time inputs
		assign abcd_policy_ad_state_out =  abcd_policy_ad_c_state;
		//internal vars
		

	endmodule

	

// NOTE: Input Select LUT uses Output LUT :)
// INPUT Select Look Up Table
// Inputs: recovery references from each policy's input module
// Outputs: final signals for inputs
//module F_LUT_Input_Edit (
		// Inputs (plant to controller) 
		//input wire A_ptc_in,
		//output wire A_ptc_out, // final
		
		//input wire  abcd_policy_ab_input_recovery_ref,
		//input wire  abcd_policy_ac_input_recovery_ref,
		//input wire  abcd_policy_ad_input_recovery_ref,
		
		//input wire clk
	//);
	
//endmodule
	
// OUTPUT Select Look Up Table
// Inputs: recovery references from each policy's output module
// Outputs: final signals for outputs
module F_LUT_Output_Edit (
		// Inputs (plant to controller) 
		input wire A_ptc_in,
		output wire A_ptc_out, // final
		

		// Outputs (controller to plant) 
		input wire B_ctp_in,
		output wire B_ctp_out, // final
		
		input wire C_ctp_in,
		output wire C_ctp_out, // final
		
		input wire D_ctp_in,
		output wire D_ctp_out, // final
		
		input wire  abcd_policy_ab_output_recovery_ref,
		input wire  abcd_policy_ac_output_recovery_ref,
		input wire  abcd_policy_ad_output_recovery_ref,
		
		input wire clk
	);

	reg A = 0;
	reg B = 0;
	reg C = 0;
	reg D = 0;
	
	
	//initial begin
		// A_ptc_out = 0;
		// B_ctp_out = 0;// C_ctp_out = 0;// D_ctp_out = 0;
	//end

	// LUT
	always @(posedge clk) begin
		// Default to original signal (to preserve transparency)
		A = A_ptc_in;
		B = B_ctp_in;
		C = C_ctp_in;
		D = D_ctp_in;
		

		case({ abcd_policy_ab_output_recovery_ref, abcd_policy_ac_output_recovery_ref, abcd_policy_ad_output_recovery_ref }) 
			3'b000: begin
				A = 1;
				B = 1;
				C = 1;
				D = 1;
				end

			default: begin 
					A = A_ptc_in;
					B = B_ctp_in;
					C = C_ctp_in;
					D = D_ctp_in;
				end
		endcase
		
		//A_ptc_out = A;
		//B_ctp_out = B;
		//C_ctp_out = C;
		//D_ctp_out = D;

	end
	
	assign A_ptc_out = A;
	assign B_ctp_out = B;
	assign C_ctp_out = C;
	assign D_ctp_out = D;
	
endmodule

module manual_series_sim_FSM (
	input wire A_ptc_enf,
	output wire A_ptc_enf_out,
	output wire A_ptc_enf_trans,
	
	input wire B_ctp_enf,
	output wire B_ctp_enf_out,
	output wire B_ctp_enf_trans,
	
	input wire C_ctp_enf,
	output wire C_ctp_enf_out,
	output wire C_ctp_enf_trans,
	
	input wire D_ctp_enf,
	output wire D_ctp_enf_out,
	output wire D_ctp_enf_trans,
	
	input wire clk,
	output wire clk_input_1,
	output wire clk_input_2,
	output wire clk_input_3,
	output wire clk_output_1,
	output wire clk_output_2,
	output wire clk_output_3,
	output wire clk_transition,
	output wire [3:0] state_out
);
	reg [3:0] c_state = 0;

	reg c_in_1 = 0;
	reg c_in_2 = 0;
	reg c_in_3 = 0;
	reg c_out_1 = 0;
	reg c_out_2 = 0;
	reg c_out_3 = 0;
	reg c_trans = 0;
	
	reg A_enf = 0;
	reg A_trans = 0;
	
	reg B_enf = 0;
	reg B_trans = 0;
	
	reg C_enf = 0;
	reg C_trans = 0;
	
	reg D_enf = 0;
	reg D_trans = 0;
	
	always @(posedge clk)
	begin
		A_enf = 0;
		A_trans = 0;
		
		B_enf = 0;
		B_trans = 0;
		
		C_enf = 0;
		C_trans = 0;
		
		D_enf = 0;
		D_trans = 0;
		
		c_in_1 = 0;
		c_in_2 = 0;
		c_in_3 = 0;
		c_out_1 = 0;
		c_out_2 = 0;
		c_out_3 = 0;
		c_trans = 0;

		if (c_state == 4'b1001) begin
			c_state = 0;
		end
		else begin
			c_state = c_state + 1;
		end

		case (c_state)
		4'b0001: begin
			// Input 1
			c_in_1 = 1;
		end
		4'b0010: begin
			// Input 2
			c_in_2 = 1;
		end
		4'b0011: begin
			// Input 3
			c_in_3 = 1;
		end
		4'b0100: begin
			// Express Input 
			
			A_enf = A_ptc_enf;
			A_trans = A_ptc_enf;

			// Controller
		end
		4'b0101: begin
			// Output 1
			c_out_1 = 1;
		end
		4'b0110: begin
			// Output 2
			c_out_2 = 1;
		end
		4'b0111: begin
			// Output 3
			c_out_3 = 1;
		end
		4'b1000: begin
			// Express Output
			
			B_enf = B_ctp_enf;
			B_trans = B_ctp_enf;
			C_enf = C_ctp_enf;
			C_trans = C_ctp_enf;
			D_enf = D_ctp_enf;
			D_trans = D_ctp_enf;

		end
		4'b0101: begin
			// Transition
			c_trans = 1;
		end
	endcase

	end
	
	assign A_ptc_enf_out = A_enf;
	assign A_ptc_enf_trans = A_trans;
	
	assign B_ctp_enf_out = B_enf;
	assign B_ctp_enf_trans = B_trans;
	assign C_ctp_enf_out = C_enf;
	assign C_ctp_enf_trans = C_trans;
	assign D_ctp_enf_out = D_enf;
	assign D_ctp_enf_trans = D_trans;

	assign state_out = c_state;
	assign clk_input_1 = c_in_1;
	assign clk_input_2 = c_in_2;
	assign clk_input_3 = c_in_3;
	assign clk_output_1 = c_out_1;
	assign clk_output_2 = c_out_2;
	assign clk_output_3 = c_out_3;
	assign clk_transition = c_trans;

endmodule

module manual_series_F_abcd(

		//inputs (plant to controller)
		A_ptc,
		A_ptc_out,
		A_ptc_out_ignore,
		A_ptc_out_latched,
		A_ptc_out_trans,
		//OUTPUT_A_ptc_enf_final,
		
		//outputs (controller to plant)
		B_ctp,
		B_ctp_out,
		B_ctp_out_ignore,
		B_ctp_out_latched,
		B_ctp_out_trans,
		//OUTPUT_B_ctp_enf_final,
		C_ctp,
		C_ctp_out,
		C_ctp_out_ignore,
		C_ctp_out_latched,
		C_ctp_out_trans,
		//OUTPUT_C_ctp_enf_final,
		D_ctp,
		D_ctp_out,
		D_ctp_out_ignore,
		D_ctp_out_latched,
		D_ctp_out_trans,
		//OUTPUT_D_ctp_enf_final,
		
		//helper outputs//abcd_policy_ab_state_out,
		
		abcd_policy_ab_input_recovery_ref,
		abcd_policy_ab_output_recovery_ref,
		//abcd_policy_ac_state_out,
		
		abcd_policy_ac_input_recovery_ref,
		abcd_policy_ac_output_recovery_ref,
		//abcd_policy_ad_state_out,
		
		abcd_policy_ad_input_recovery_ref,
		abcd_policy_ad_output_recovery_ref,
		
		fsm_state,

		clk_input_1,
		clk_input_2,
		clk_input_3,
		clk_output_1,
		clk_output_2,
		clk_output_3,
		clk_transition,
		clk
	);

	input wire clk;

	output wire clk_input_1;
	output wire clk_input_2;
	output wire clk_input_3;
	output wire clk_output_1;
	output wire clk_output_2;
	output wire clk_output_3;
	output wire clk_transition;
	output wire [3:0] fsm_state;
	
	input wire A_ptc;
	output wire A_ptc_out;
	output wire A_ptc_out_latched;
	output wire A_ptc_out_ignore;
	output wire A_ptc_out_trans;
	
	input wire B_ctp;
	output wire B_ctp_out;
	output wire B_ctp_out_latched;
	output wire B_ctp_out_ignore;
	output wire B_ctp_out_trans;
	input wire C_ctp;
	output wire C_ctp_out;
	output wire C_ctp_out_latched;
	output wire C_ctp_out_ignore;
	output wire C_ctp_out_trans;
	input wire D_ctp;
	output wire D_ctp_out;
	output wire D_ctp_out_latched;
	output wire D_ctp_out_ignore;
	output wire D_ctp_out_trans;
	
	// Internal Variables
	

	// States
	wire  abcd_policy_ab_state;

	// Recovery References
	output wire  abcd_policy_ab_input_recovery_ref;
	output wire  abcd_policy_ab_output_recovery_ref;
	
	// Internal Variables
	

	// States
	wire  abcd_policy_ac_state;

	// Recovery References
	output wire  abcd_policy_ac_input_recovery_ref;
	output wire  abcd_policy_ac_output_recovery_ref;
	
	// Internal Variables
	

	// States
	wire  abcd_policy_ad_state;

	// Recovery References
	output wire  abcd_policy_ad_input_recovery_ref;
	output wire  abcd_policy_ad_output_recovery_ref;
	
	manual_series_sim_FSM instance_manual_series_sim_FSM(
		.A_ptc_enf(A_ptc_out),
		.A_ptc_enf_out(A_ptc_out_latched),
		.A_ptc_enf_trans(A_ptc_out_trans),
		
		.B_ctp_enf(B_ctp_out),
		.B_ctp_enf_out(B_ctp_out_latched),
		.B_ctp_enf_trans(B_ctp_out_trans),
		.C_ctp_enf(C_ctp_out),
		.C_ctp_enf_out(C_ctp_out_latched),
		.C_ctp_enf_trans(C_ctp_out_trans),
		.D_ctp_enf(D_ctp_out),
		.D_ctp_enf_out(D_ctp_out_latched),
		.D_ctp_enf_trans(D_ctp_out_trans),
		
		.clk(clk),
		.clk_input_1(clk_input_1),
		.clk_input_2(clk_input_2),
		.clk_input_3(clk_input_3),
		.clk_output_1(clk_output_1),
		.clk_output_2(clk_output_2),
		.clk_output_3(clk_output_3),
		.clk_transition(clk_transition),
		.state_out(fsm_state)
	);
	
	F_combinatorialVerilog_abcd_policy_ab_input instance_policy_ab_input(
		.abcd_policy_ab_state_in(abcd_policy_ab_state),
		.abcd_policy_ab_input_recovery_ref(abcd_policy_ab_input_recovery_ref),
		
		.A_ptc_in(A_ptc),
		
		
		.clk(clk_input_1)
	);
	
	F_combinatorialVerilog_abcd_policy_ac_input instance_policy_ac_input(
		.abcd_policy_ac_state_in(abcd_policy_ac_state),
		.abcd_policy_ac_input_recovery_ref(abcd_policy_ac_input_recovery_ref),
		
		.A_ptc_in(A_ptc),
		
		
		.clk(clk_input_2)
	);
	
	F_combinatorialVerilog_abcd_policy_ad_input instance_policy_ad_input(
		.abcd_policy_ad_state_in(abcd_policy_ad_state),
		.abcd_policy_ad_input_recovery_ref(abcd_policy_ad_input_recovery_ref),
		
		.A_ptc_in(A_ptc),
		
		
		.clk(clk_input_3)
	);
	
	F_LUT_Output_Edit instance_LUT_Input_Edit(
		
		.A_ptc_in(A_ptc),
		.A_ptc_out(A_ptc_out),
		
		.B_ctp_in(B_ctp),
		.B_ctp_out(B_ctp_out_ignore),
		.C_ctp_in(C_ctp),
		.C_ctp_out(C_ctp_out_ignore),
		.D_ctp_in(D_ctp),
		.D_ctp_out(D_ctp_out_ignore),
		
		.abcd_policy_ab_output_recovery_ref(abcd_policy_ab_input_recovery_ref),
		
		.abcd_policy_ac_output_recovery_ref(abcd_policy_ac_input_recovery_ref),
		
		.abcd_policy_ad_output_recovery_ref(abcd_policy_ad_input_recovery_ref),
		
		.clk(clk_input_3)
	);
	
	F_combinatorialVerilog_abcd_policy_ab_output instance_policy_ab_output(
		
		.A_ptc_out(A_ptc_out_trans),
		

		
		.B_ctp_in(B_ctp),
		
		.C_ctp_in(C_ctp),
		
		.D_ctp_in(D_ctp),
		
		.abcd_policy_ab_state_in(abcd_policy_ab_state),
		.abcd_policy_ab_output_recovery_ref(abcd_policy_ab_output_recovery_ref),
		
		
		.clk(clk_output_1)
	);
	
	F_combinatorialVerilog_abcd_policy_ac_output instance_policy_ac_output(
		
		.A_ptc_out(A_ptc_out_trans),
		

		
		.B_ctp_in(B_ctp),
		
		.C_ctp_in(C_ctp),
		
		.D_ctp_in(D_ctp),
		
		.abcd_policy_ac_state_in(abcd_policy_ac_state),
		.abcd_policy_ac_output_recovery_ref(abcd_policy_ac_output_recovery_ref),
		
		
		.clk(clk_output_2)
	);
	
	F_combinatorialVerilog_abcd_policy_ad_output instance_policy_ad_output(
		
		.A_ptc_out(A_ptc_out_trans),
		

		
		.B_ctp_in(B_ctp),
		
		.C_ctp_in(C_ctp),
		
		.D_ctp_in(D_ctp),
		
		.abcd_policy_ad_state_in(abcd_policy_ad_state),
		.abcd_policy_ad_output_recovery_ref(abcd_policy_ad_output_recovery_ref),
		
		
		.clk(clk_output_3)
	);
	
	F_LUT_Output_Edit instance_LUT_Output_Edit(
		
		.A_ptc_in(A_ptc_out_latched),
		.A_ptc_out(A_ptc_out_ignore),
		
		.B_ctp_in(B_ctp),
		.B_ctp_out(B_ctp_out),
		.C_ctp_in(C_ctp),
		.C_ctp_out(C_ctp_out),
		.D_ctp_in(D_ctp),
		.D_ctp_out(D_ctp_out),
		
		.abcd_policy_ab_output_recovery_ref(abcd_policy_ab_output_recovery_ref),
		
		.abcd_policy_ac_output_recovery_ref(abcd_policy_ac_output_recovery_ref),
		
		.abcd_policy_ad_output_recovery_ref(abcd_policy_ad_output_recovery_ref),
		
		.clk(clk_output_3)
	);
	
	F_combinatorialVerilog_abcd_policy_ab_transition instance_policy_ab_transition(
		
		.A_ptc_final(A_ptc_out_trans),
		
		
		.B_ctp_final(B_ctp_out_trans),
		
		.C_ctp_final(C_ctp_out_trans),
		
		.D_ctp_final(D_ctp_out_trans),
		
		
		
		.abcd_policy_ab_state_out(abcd_policy_ab_state),
		.clk(clk_transition)
	);
	
	F_combinatorialVerilog_abcd_policy_ac_transition instance_policy_ac_transition(
		
		.A_ptc_final(A_ptc_out_trans),
		
		
		.B_ctp_final(B_ctp_out_trans),
		
		.C_ctp_final(C_ctp_out_trans),
		
		.D_ctp_final(D_ctp_out_trans),
		
		
		
		.abcd_policy_ac_state_out(abcd_policy_ac_state),
		.clk(clk_transition)
	);
	
	F_combinatorialVerilog_abcd_policy_ad_transition instance_policy_ad_transition(
		
		.A_ptc_final(A_ptc_out_trans),
		
		
		.B_ctp_final(B_ctp_out_trans),
		
		.C_ctp_final(C_ctp_out_trans),
		
		.D_ctp_final(D_ctp_out_trans),
		
		
		
		.abcd_policy_ad_state_out(abcd_policy_ad_state),
		.clk(clk_transition)
	);
	

endmodule

