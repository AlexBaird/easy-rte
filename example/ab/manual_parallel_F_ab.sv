
//This file should be called F_ab.sv
//This is autogenerated code. Edit by hand at your peril!!!

//Warning: This is experimental parallel composition code.


module F_combinatorialVerilog_ab_policy_a_input(
	//inputs (plant to controller)


	input wire [1:0] ab_policy_a_state_in,

	input wire clk
);

	//For each policy, we need define types for the state machines
	localparam
		POLICY_STATE_ab_a_a0 = 0,
		POLICY_STATE_ab_a_a1 = 1,
		POLICY_STATE_ab_a_violation = 2;

	//reg recoveryRef = 0;
	
	//internal vars
	
	// initial begin
	// 	policy_a_no_edit = 1;
	// end

	always @* begin
		
		// Default no change to inputs/outputs (transparency) 

		// Do we need //recoveryRef default?

		// Default no clock reset
		

		//input policies
		
			//INPUT POLICY a BEGIN 
			case(ab_policy_a_state_in)
				POLICY_STATE_ab_a_a0: begin
					
				end
				POLICY_STATE_ab_a_a1: begin
					
				end
				
			endcase
		
		//INPUT POLICY a END
	end

endmodule

module F_combinatorialVerilog_ab_policy_a_output(
	//outputs (controller to plant)
	input wire  A_ctp_in,
	output reg  A_ctp_out,
	
	input wire  B_ctp_in,
	output reg  B_ctp_out,

	input wire [1:0] ab_policy_a_state_in,

	output wire [1:0] ab_policy_a_output_recovery_ref,

	input wire clk
);

	//For each policy, we need define types for the state machines
	localparam
		POLICY_STATE_ab_a_a0 = 0,
		POLICY_STATE_ab_a_a1 = 1,
		POLICY_STATE_ab_a_violation = 2;

	reg A = 0;
	reg B = 0;
	reg [1:0] recoveryRef = 0;

	always @* begin
		// Default no change to inputs/outputs (transparency) 
		A = A_ctp_in;
		B = B_ctp_in;

		recoveryRef	= 0;

		// Default no clock reset

		//output policies
			//OUTPUT POLICY a BEGIN 
		
		case(ab_policy_a_state_in)
			POLICY_STATE_ab_a_a0: begin
				
				if (!(A) && B) begin
					//transition a0 -> violation on (!A and B)
					//select a transition to solve the problem
					
					//Selected non-violation transition "a0 -> a1 on ( A )" and action is required
					A = 1;

					recoveryRef = 1;
					
				end 
				if (!(A) && !(B)) begin
					//transition a0 -> violation on (!A and !B)
					//select a transition to solve the problem
					
					//Selected non-violation transition "a0 -> a1 on ( A )" and action is required
					A = 1;

					recoveryRef = 2;

					
				end 
			end
			POLICY_STATE_ab_a_a1: begin
				
				if (A && B) begin
					//transition a1 -> violation on (A and B)
					//select a transition to solve the problem
					
					//Selected non-violation transition "a1 -> a0 on ( !A )" and action is required
					A = 0;

					recoveryRef = 3;
					
					
				end 
				if (A && !(B)) begin
					//transition a1 -> violation on (A and !B)
					//select a transition to solve the problem
					
					//Selected non-violation transition "a1 -> a0 on ( !A )" and action is required
					A = 0;

					recoveryRef = 4;

					
				end 
			end
			
		endcase
		//OUTPUT POLICY a END

		// Check if any enforcement action required for this policy
		// TODO: Move this to within each enforcement action (when edit required set no_edit to false)
		// if ((A === A_ctp_in) & (B === B_ctp_in)) begin
		// 	policy_a_no_edit <= 1;
		// end else begin
		// 	policy_a_no_edit <= 0;
		// end
		
		// Post input enforced 
		
		// Post output enforced 
		A_ctp_out = A;
		B_ctp_out = B;
		
	end
	assign ab_policy_a_output_recovery_ref = recoveryRef;

endmodule

module F_combinatorialVerilog_ab_policy_a_transition(
	input wire A_ctp_final,
	input wire B_ctp_final,

	output wire [1:0] ab_policy_a_state_out,

	input wire clk
);
	//For each policy, we need define types for the state machines
	localparam
		POLICY_STATE_ab_a_a0 = 0,
		POLICY_STATE_ab_a_a1 = 1,
		POLICY_STATE_ab_a_violation = 2;

	reg A = 0; // Maybe remove these?
	reg B = 0;

	//For each policy, we need a reg for the state machine
	reg [1:0] ab_policy_a_c_state = 0;
	reg [1:0] ab_policy_a_n_state = 0;

	initial begin
		// A = 0; Maybe needed?? If transition module outputs ctrl sigs
		// B = 0;
		ab_policy_a_c_state = 0;
		ab_policy_a_n_state = 0;
	end

	always @(posedge clk)
	begin
		ab_policy_a_c_state = ab_policy_a_n_state;

		//increment timers/clocks
		//internal vars
		
	end

	always @* begin
		A = A_ctp_final;
		B = B_ctp_final;

		//transTaken_ab_policy_a = 0;
		//select transition to advance state
		case(ab_policy_a_c_state)
			POLICY_STATE_ab_a_a0: begin
				
				if (A) begin
					//transition a0 -> a1 on ( A )
					ab_policy_a_n_state = POLICY_STATE_ab_a_a1;
					//set expressions
					
					//transTaken_ab_policy_a = 1;
				end 
				else if (!(A) && B) begin
					//transition a0 -> violation on (!A and B)
					ab_policy_a_n_state = POLICY_STATE_ab_a_violation;
					//set expressions
					
					//transTaken_ab_policy_a = 1;
				end 
				else if (!(A) && !(B)) begin
					//transition a0 -> violation on (!A and !B)
					ab_policy_a_n_state = POLICY_STATE_ab_a_violation;
					//set expressions
					
					//transTaken_ab_policy_a = 1;
				end  else begin
					//only possible in a violation
					ab_policy_a_n_state = POLICY_STATE_ab_a_violation;
					//transTaken_ab_policy_a = 1;
				end
			end
			POLICY_STATE_ab_a_a1: begin
				
				if (!(A)) begin
					//transition a1 -> a0 on ( !A )
					ab_policy_a_n_state = POLICY_STATE_ab_a_a0;
					//set expressions
					
					//transTaken_ab_policy_a = 1;
				end 
				else if (A && B) begin
					//transition a1 -> violation on (A and B)
					ab_policy_a_n_state = POLICY_STATE_ab_a_violation;
					//set expressions
					
					//transTaken_ab_policy_a = 1;
				end 
				else if (A && !(B)) begin
					//transition a1 -> violation on (A and !B)
					ab_policy_a_n_state = POLICY_STATE_ab_a_violation;
					//set expressions
					
					//transTaken_ab_policy_a = 1;
				end  else begin
					//only possible in a violation
					ab_policy_a_n_state = POLICY_STATE_ab_a_violation;
					//transTaken_ab_policy_a = 1;
				end
			end
			
			default begin
				//if we are here, we're in the violation state
				//the violation state permanently stays in violation
				ab_policy_a_n_state = POLICY_STATE_ab_a_violation;
				//transTaken_ab_policy_a = 1;
			end
		endcase
	end

	assign ab_policy_a_state_out =  ab_policy_a_c_state;

endmodule


module F_combinatorialVerilog_ab_policy_b_input (
	//inputs (plant to controller)


	input wire [1:0] ab_policy_b_state_in,

	input wire clk
);

	//For each policy, we need define types for the state machines
	localparam
		POLICY_STATE_ab_b_b0 = 0,
		POLICY_STATE_ab_b_b1 = 1,
		POLICY_STATE_ab_b_violation = 2;

	//reg recoveryRef = 0;
	
	//internal vars
	
	// initial begin
	// 	policy_a_no_edit = 1;
	// end

	always @* begin
		
		// Default no change to inputs/outputs (transparency) 

		// Do we need //recoveryRef default?

		// Default no clock reset
		

		//input policies
		
			//INPUT POLICY a BEGIN 
			case(ab_policy_b_state_in)
				POLICY_STATE_ab_b_b0: begin
					
				end
				POLICY_STATE_ab_b_b1: begin
					
				end
				
			endcase
		
		//INPUT POLICY a END
	end

endmodule

module F_combinatorialVerilog_ab_policy_b_output (
	//outputs (controller to plant)
	input wire  A_ctp_in,
	output reg  A_ctp_out,
	
	input wire  B_ctp_in,
	output reg  B_ctp_out,

	input wire [1:0] ab_policy_b_state_in,

	output reg [1:0] ab_policy_b_output_recovery_ref,

	input wire clk
);
	//For each policy, we need define types for the state machines
	localparam
		POLICY_STATE_ab_b_b0 = 0,
		POLICY_STATE_ab_b_b1 = 1,
		POLICY_STATE_ab_b_violation = 2;

	reg A = 0;
	reg B = 0;
	reg [1:0] recoveryRef = 0;

	always @* begin
		// Default no change to inputs/outputs (transparency) 
		A = A_ctp_in;
		B = B_ctp_in;
		recoveryRef	= 0;

		//output policies
		//OUTPUT POLICY b BEGIN 
		
		case(ab_policy_b_state_in)
			POLICY_STATE_ab_b_b0: begin
				
				if (A && !(B)) begin
					//transition b0 -> violation on (A and !B)
					//select a transition to solve the problem
					
					//Selected non-violation transition "b0 -> b1 on ( B )" and action is required
					B = 1;

					recoveryRef = 1;
					
				end 
				if (!(A) && !(B)) begin
					//transition b0 -> violation on (!A and !B)
					//select a transition to solve the problem
					
					//Selected non-violation transition "b0 -> b1 on ( B )" and action is required
					B = 1;
					
					recoveryRef = 2;
				end 
			end
			POLICY_STATE_ab_b_b1: begin
				
				if (A && B) begin
					//transition b1 -> violation on (A and B)
					//select a transition to solve the problem
					
					//Selected non-violation transition "b1 -> b0 on ( !B )" and action is required
					B = 0;
					
					recoveryRef = 3;
				end 
				if (!(A) && B) begin
					//transition b1 -> violation on (!A and B)
					//select a transition to solve the problem
					
					//Selected non-violation transition "b1 -> b0 on ( !B )" and action is required
					B = 0;
					
					recoveryRef = 4;
				end 
			end
			
		endcase
		
		//OUTPUT POLICY b END

		// TODO: Move this to within each enforcement action (when edit required set no_edit to false)
		// if ((A === A_ctp_in) & (B === B_ctp_in)) begin
		// 	policy_b_no_edit <= 1;
		// end else begin
		// 	policy_b_no_edit <= 0;
		// end
		
		// Post input enforced 
		
		// Post output enforced 
		A_ctp_out = A;
		B_ctp_out = B;
		ab_policy_b_output_recovery_ref = recoveryRef;
	end
endmodule

module F_combinatorialVerilog_ab_policy_b_transition (
	input wire A_ctp_final,
	input wire B_ctp_final,

	output wire [1:0] ab_policy_b_state_out,

	input wire clk
);

	//For each policy, we need define types for the state machines
	localparam
		POLICY_STATE_ab_b_b0 = 0,
		POLICY_STATE_ab_b_b1 = 1,
		POLICY_STATE_ab_b_violation = 2;

	reg A = 0; // Maybe remove these?
	reg B = 0;

	//For each policy, we need a reg for the state machine
	reg [1:0] ab_policy_b_c_state = 0;
	reg [1:0] ab_policy_b_n_state = 0;

	initial begin
		// A = 0; Maybe needed?? If transition module outputs ctrl sigs
		// B = 0;
		ab_policy_b_c_state = 0;
		ab_policy_b_n_state = 0;
	end

	always @(posedge clk)
	begin
		ab_policy_b_c_state = ab_policy_b_n_state;

		//increment timers/clocks
		//internal vars
		
	end

	always @* begin
		A = A_ctp_final;
		B = B_ctp_final;

		//transTaken_ab_policy_a = 0;
		//select transition to advance state
		case(ab_policy_b_c_state)
			POLICY_STATE_ab_b_b0: begin
				
				if (B) begin
					//transition b0 -> b1 on ( B )
					ab_policy_b_n_state = POLICY_STATE_ab_b_b1;
					//set expressions
					
					//transTaken_ab_policy_b = 1;
				end 
				else if (A && !(B)) begin
					//transition b0 -> violation on (A and !B)
					ab_policy_b_n_state = POLICY_STATE_ab_b_violation;
					//set expressions
					
					//transTaken_ab_policy_b = 1;
				end 
				else if (!(A) && !(B)) begin
					//transition b0 -> violation on (!A and !B)
					ab_policy_b_n_state = POLICY_STATE_ab_b_violation;
					//set expressions
					
					//transTaken_ab_policy_b = 1;
				end  else begin
					//only possible in a violation
					ab_policy_b_n_state = POLICY_STATE_ab_b_violation;
					//transTaken_ab_policy_b = 1;
				end
			end
			POLICY_STATE_ab_b_b1: begin
				
				if (!(B)) begin
					//transition b1 -> b0 on ( !B )
					ab_policy_b_n_state = POLICY_STATE_ab_b_b0;
					//set expressions
					
					//transTaken_ab_policy_b = 1;
				end 
				else if (A && B) begin
					//transition b1 -> violation on (A and B)
					ab_policy_b_n_state = POLICY_STATE_ab_b_violation;
					//set expressions
					
					//transTaken_ab_policy_b = 1;
				end 
				else if (!(A) && B) begin
					//transition b1 -> violation on (!A and B)
					ab_policy_b_n_state = POLICY_STATE_ab_b_violation;
					//set expressions
					
					//transTaken_ab_policy_b = 1;
				end  else begin
					//only possible in a violation
					ab_policy_b_n_state = POLICY_STATE_ab_b_violation;
					//transTaken_ab_policy_b = 1;
				end
			end
			
			default begin
				//if we are here, we're in the violation state
				//the violation state permanently stays in violation
				ab_policy_b_n_state = POLICY_STATE_ab_b_violation;
				//transTaken_ab_policy_b = 1;
			end
		endcase
	end

	assign ab_policy_b_state_out =  ab_policy_b_c_state;

endmodule




// Merge blocks for each input and output
//merge inputs (plant to controller)

//merge outputs (controller to plant)
module merge_A (
		input wire A_ctp_in, // original environment signal
		input wire [1:0] A_ctp_enf,
		input wire [1:0] A_no_edit_enf,
		output reg A_enf_combined,
		output reg A_none_care,
		output reg A_ctp_out_final
	);

	initial begin
		A_enf_combined = 0;
		A_none_care = 0;
		A_ctp_out_final = 0;
	end

	always@(A_ctp_enf, A_no_edit_enf)	begin
		// OR all enforcer output
		A_enf_combined <= |A_ctp_enf;
		
		// AND the don't cares (to figure out if none care)
		A_none_care <= &A_no_edit_enf;

	end

	reg A_env_delay;
	reg A_env_delay_2;
	always @(A_ctp_in) begin
		A_env_delay <= A_ctp_in;
	end
	always @(A_env_delay) begin
		A_env_delay_2 <= A_env_delay;
	end

	// Mux to select original if none care
	always @(A_enf_combined, A_none_care, A_env_delay_2) begin
		A_ctp_out_final <= (A_none_care)? A_env_delay_2: A_enf_combined;
	end

endmodule

module merge_B (
		input wire B_ctp_in, // original environment signal
		input wire [1:0] B_ctp_enf,
		input wire [1:0] B_no_edit_enf,
		output reg B_enf_combined,
		output reg B_none_care,
		output reg B_ctp_out_final
	);

	initial begin
		B_enf_combined = 0;
		B_none_care = 0;
		B_ctp_out_final = 0;
	end

	always@(B_ctp_enf, B_no_edit_enf)	begin
		// OR all enforcer output
		B_enf_combined <= |B_ctp_enf;
		
		// AND the don't cares (to figure out if none care)
		B_none_care <= &B_no_edit_enf;

	end

	reg B_env_delay;
	reg B_env_delay_2;
	always @(B_ctp_in) begin
		B_env_delay <= B_ctp_in;
	end
	always @(B_env_delay) begin
		B_env_delay_2 <= B_env_delay;
	end

	// Mux to select original if none care
	always @(B_enf_combined, B_none_care, B_env_delay_2) begin
		B_ctp_out_final <= (B_none_care)? B_env_delay_2: B_enf_combined;
	end

endmodule

