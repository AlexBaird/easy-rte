
//This file should be called F_ab5.sv
//This is autogenerated code. Edit by hand at your peril!!!

//Warning: This is experimental parallel composition code.


	module F_combinatorialVerilog_ab5_policy_AB5_input (
		
		//inputs (plant to controller)
		input wire  A_ptc_in,
		
		// Internal Variables Input
		input wire [63:0] v,
		
		//helpful state output input var
		input wire [1:0] ab5_policy_AB5_state_in,
		
		// Recovery Reference
		output wire [2:0] ab5_policy_AB5_input_recovery_ref,

		input wire clk
		);

		//For each policy, we need define types for the state machines
		localparam
			POLICY_STATE_ab5_AB5_init = 0,
			POLICY_STATE_ab5_AB5_s0 = 1,
			POLICY_STATE_ab5_AB5_s1 = 2,
			POLICY_STATE_ab5_AB5_violation = 3;

		
		reg A = 0;
		
		// Recovery ref declare and init
		reg [2:0] recoveryReference = 0;

		initial begin
			recoveryReference = 0;
		end

		always @(A_ptc_in, clk, ab5_policy_AB5_state_in) begin
			
			// Default no change to inputs (transparency) 
			A = A_ptc_in;
			
			recoveryReference = 0;

			//input policies
			
				//INPUT POLICY AB5 BEGIN 
				case(ab5_policy_AB5_state_in)
					POLICY_STATE_ab5_AB5_init: begin
						// Default location recovery reference
						
						
					end
					POLICY_STATE_ab5_AB5_s0: begin
						// Default location recovery reference
						recoveryReference = 3;
						
						if (!(A)) begin
							//transition s0 -> violation on not (A)
							//select a transition to solve the problem
							
							//Selected non-violation transition "s0 -> s0 on not (A)" which has an equivalent guard, so no action is required
							
							// Set recovery reference
							recoveryReference = 1;
						end
						if (A) begin
							//transition s0 -> violation on A
							//select a transition to solve the problem
							
							//Selected non-violation transition "s0 -> s1 on A" which has an equivalent guard, so no action is required
							
							// Set recovery reference
							recoveryReference = 2;
						end
					end
					POLICY_STATE_ab5_AB5_s1: begin
						// Default location recovery reference
						recoveryReference = 5;
						
						if (A && (A && v >= 5)) begin
							//transition s1 -> violation on A and A and v >= 5
							//select a transition to solve the problem
							
							//Selected non-violation transition "s1 -> s0 on not (A)" and action is required
							A = 0;
							
							// Set recovery reference
							recoveryReference = 4;
						end
						if (A) begin
							//transition s1 -> violation on A
							//select a transition to solve the problem
							
							//Selected non-violation transition "s1 -> s0 on not (A)" and action is required
							A = 0;
							
							// Set recovery reference
							recoveryReference = 6;
						end
						if (A) begin
							//transition s1 -> violation on A
							//select a transition to solve the problem
							
							//Selected non-violation transition "s1 -> s0 on not (A)" and action is required
							A = 0;
							
							// Set recovery reference
							recoveryReference = 7;
						end
					end
					
				endcase
			
			//INPUT POLICY AB5 END
		end
		assign ab5_policy_AB5_input_recovery_ref = recoveryReference;

	endmodule

	module F_combinatorialVerilog_ab5_policy_AB5_output (
		//(Final) inputs (plant to controller)
		input wire  A_ptc_out,
		


		//outputs (controller to plant)
		input wire  B_ctp_in,
		//output reg  B_ctp_out,
		

		// Internal Variables Input
		input wire [63:0] v,

		// State Input
		input wire [1:0] ab5_policy_AB5_state_in,

		// Recovery Reference Output
		output wire [2:0] ab5_policy_AB5_output_recovery_ref,

		input wire clk

	);

		//For each policy, we need define types for the state machines
		localparam
			POLICY_STATE_ab5_AB5_init = 0,
			POLICY_STATE_ab5_AB5_s0 = 1,
			POLICY_STATE_ab5_AB5_s1 = 2,
			POLICY_STATE_ab5_AB5_violation = 3;

		
		reg A = 0;
		
		reg B = 0;
		
		// Recovery ref declare and init
		reg [2:0] recoveryReference = 0;

		initial begin
			recoveryReference = 0;
		end

		always @(B_ctp_in, clk, ab5_policy_AB5_state_in) begin
			// Default no change to inputs/outputs (transparency) 
			A = A_ptc_out;
			
			B = B_ctp_in;
			
			recoveryReference = 0;

			//output policies
				//OUTPUT POLICY AB5 BEGIN 
				
				case(ab5_policy_AB5_state_in)
					POLICY_STATE_ab5_AB5_init: begin
						// Default location recovery reference
						
						
					end
					POLICY_STATE_ab5_AB5_s0: begin
						// Default location recovery reference
						recoveryReference = 3;
						
						if (!(A) && B) begin
							//transition s0 -> violation on (!A and B)
							//select a transition to solve the problem
							
							//Selected non-violation transition "s0 -> s0 on ( !A and !B )" and action is required
							B = 0;
							
							// Set recovery reference
							recoveryReference = 1;

						end 
						if (A && B) begin
							//transition s0 -> violation on (A and B)
							//select a transition to solve the problem
							
							//Selected non-violation transition "s0 -> s0 on ( !A and !B )" and action is required
							B = 0;
							
							// Set recovery reference
							recoveryReference = 2;

						end 
					end
					POLICY_STATE_ab5_AB5_s1: begin
						// Default location recovery reference
						recoveryReference = 5;
						
						if ((A && B) && ((A && B) && v >= 5)) begin
							//transition s1 -> violation on ((A and B) and ( ( A and B ) and ( v >= 5 ) ))
							//select a transition to solve the problem
							
							//Selected non-violation transition "s1 -> s0 on ( !A and B )" and action is required
							B = 1;
							
							// Set recovery reference
							recoveryReference = 4;

						end 
						if (A && B) begin
							//transition s1 -> violation on (A and B)
							//select a transition to solve the problem
							
							//Selected non-violation transition "s1 -> s0 on ( !A and B )" and action is required
							B = 1;
							
							// Set recovery reference
							recoveryReference = 6;

						end 
						if (A && !(B)) begin
							//transition s1 -> violation on (A and !B)
							//select a transition to solve the problem
							
							//Selected non-violation transition "s1 -> s0 on ( !A and B )" and action is required
							B = 1;
							
							// Set recovery reference
							recoveryReference = 7;

						end 
					end
					
				endcase
			
			//OUTPUT POLICY AB5 END
		end

		assign ab5_policy_AB5_output_recovery_ref = recoveryReference;

	endmodule

	module F_combinatorialVerilog_ab5_policy_AB5_transition (
		// Final inputs (plant to controller) 
		input wire A_ptc_final,
		
		// Final outputs (controller to plant) 
		input wire B_ctp_final,
		

		// Internal Variables Output
		output wire [63:0] v_out,

		// State Output
		output wire [1:0] ab5_policy_AB5_state_out,

		input wire clk
		);
		
		//For each policy, we need define types for the state machines
		localparam
			POLICY_STATE_ab5_AB5_init = 0,
			POLICY_STATE_ab5_AB5_s0 = 1,
			POLICY_STATE_ab5_AB5_s1 = 2,
			POLICY_STATE_ab5_AB5_violation = 3;
		
		// Maybe remove these? 
		reg A = 0;
		
		reg B = 0;
		
		//internal vars
		reg [63:0] v = 0;
		reg reset_v;
		

		//For each policy, we need a reg for the state machine
		reg [1:0] ab5_policy_AB5_c_state = 0;
		reg [1:0] ab5_policy_AB5_n_state = 0;

		initial begin
			ab5_policy_AB5_c_state = 0;
			ab5_policy_AB5_n_state = 0;
		end

		always @(posedge clk)
		begin
			ab5_policy_AB5_c_state = ab5_policy_AB5_n_state;

			//increment timers/clocks
			//internal vars
			if (reset_v === 1) begin
				v = 0;
			end else begin
				v = v + 1;
			end 
		end

		always @* begin
			
			A = A_ptc_final; 
			
			B = B_ctp_final; 

			// Default no location change
			ab5_policy_AB5_n_state = ab5_policy_AB5_c_state;
			
			// Default no clock reset
			reset_v = 0;

			//transTaken_ab5_policy_AB5 = 0;
			//select transition to advance state
			case(ab5_policy_AB5_c_state)
				POLICY_STATE_ab5_AB5_init: begin
					
					 if ((!(A) && !(B)) || (A && B)) begin
						//transition init -> init on ( !A and !B ) or ( A and B )
						ab5_policy_AB5_n_state = POLICY_STATE_ab5_AB5_init;
						//set expressions
						
						//transTaken_ab5_policy_AB5 = 1;
					end  
					else if (!(A) && B) begin
						//transition init -> s0 on ( !A and B )
						ab5_policy_AB5_n_state = POLICY_STATE_ab5_AB5_s0;
						//set expressions
						reset_v = 1;
						//transTaken_ab5_policy_AB5 = 1;
					end  
					else if (A && !(B)) begin
						//transition init -> s1 on ( A and !B )
						ab5_policy_AB5_n_state = POLICY_STATE_ab5_AB5_s1;
						//set expressions
						reset_v = 1;
						//transTaken_ab5_policy_AB5 = 1;
					end   else begin
						//only possible in a violation
						ab5_policy_AB5_n_state = POLICY_STATE_ab5_AB5_violation;
						//transTaken_ab5_policy_AB5 = 1;
					end
				end
				POLICY_STATE_ab5_AB5_s0: begin
					
					 if (!(A) && !(B)) begin
						//transition s0 -> s0 on ( !A and !B )
						ab5_policy_AB5_n_state = POLICY_STATE_ab5_AB5_s0;
						//set expressions
						reset_v = 1;
						//transTaken_ab5_policy_AB5 = 1;
					end  
					else if (A && !(B)) begin
						//transition s0 -> s1 on ( A and !B )
						ab5_policy_AB5_n_state = POLICY_STATE_ab5_AB5_s1;
						//set expressions
						reset_v = 1;
						//transTaken_ab5_policy_AB5 = 1;
					end  
					else if (!(A) && B) begin
						//transition s0 -> violation on (!A and B)
						ab5_policy_AB5_n_state = POLICY_STATE_ab5_AB5_violation;
						//set expressions
						
						//transTaken_ab5_policy_AB5 = 1;
					end  
					else if (A && B) begin
						//transition s0 -> violation on (A and B)
						ab5_policy_AB5_n_state = POLICY_STATE_ab5_AB5_violation;
						//set expressions
						
						//transTaken_ab5_policy_AB5 = 1;
					end  
					  else begin
						//only possible in a violation
						ab5_policy_AB5_n_state = POLICY_STATE_ab5_AB5_violation;
						//transTaken_ab5_policy_AB5 = 1;
					end
				end
				POLICY_STATE_ab5_AB5_s1: begin
					
					 if ((!(A) && !(B)) && v < 5) begin
						//transition s1 -> s1 on ( ( !A and !B ) and v < 5 )
						ab5_policy_AB5_n_state = POLICY_STATE_ab5_AB5_s1;
						//set expressions
						
						//transTaken_ab5_policy_AB5 = 1;
					end  
					else if (!(A) && B) begin
						//transition s1 -> s0 on ( !A and B )
						ab5_policy_AB5_n_state = POLICY_STATE_ab5_AB5_s0;
						//set expressions
						
						//transTaken_ab5_policy_AB5 = 1;
					end  
					else if ((A && B) && ((A && B) && v >= 5)) begin
						//transition s1 -> violation on ((A and B) and ( ( A and B ) and ( v >= 5 ) ))
						ab5_policy_AB5_n_state = POLICY_STATE_ab5_AB5_violation;
						//set expressions
						
						//transTaken_ab5_policy_AB5 = 1;
					end  
					 
					else if (A && B) begin
						//transition s1 -> violation on (A and B)
						ab5_policy_AB5_n_state = POLICY_STATE_ab5_AB5_violation;
						//set expressions
						
						//transTaken_ab5_policy_AB5 = 1;
					end  
					else if (A && !(B)) begin
						//transition s1 -> violation on (A and !B)
						ab5_policy_AB5_n_state = POLICY_STATE_ab5_AB5_violation;
						//set expressions
						
						//transTaken_ab5_policy_AB5 = 1;
					end   else begin
						//only possible in a violation
						ab5_policy_AB5_n_state = POLICY_STATE_ab5_AB5_violation;
						//transTaken_ab5_policy_AB5 = 1;
					end
				end
				
				default begin
					//if we are here, we're in the violation state
					//the violation state permanently stays in violation
					ab5_policy_AB5_n_state = POLICY_STATE_ab5_AB5_violation;
					//transTaken_ab5_policy_AB5 = 1;
				end
			endcase

		end

		//emit state/time inputs
		assign ab5_policy_AB5_state_out =  ab5_policy_AB5_c_state;
		//internal vars
		assign v_out = v;
		

	endmodule

	

// INPUT Select Look Up Table
// Inputs: recovery references from each policy's input module
// Outputs: final signals for inputs
module F_LUT_Input_Edit (
		// Inputs (plant to controller) 
		input wire A_ptc_in,
		output reg A_ptc_out, // final
		
		input reg [2:0] ab5_policy_AB5_input_recovery_ref,
		
		input wire clk
	);

	// TODO: LUT
	
endmodule

module F_input_latch (
		input wire A_ptc_in,
		output wire A_ptc_out,
		output wire A_ptc_out_latched,
		input wire clk_input,
		input wire clk_transition
	);

	reg A_temp = 0;
	reg A_latch = 0;

	always @(A_ptc_in, clk_transition, clk_input) begin
		if (clk_input == 1) begin
			A_latch = A_ptc_in;
		end
		if (clk_input == 0) begin
			A_temp = 0;
		end
		else begin
			A_temp = A_ptc_in;			
		end
	end

	assign A_ptc_out = A_temp;
	assign A_ptc_out_latched = A_latch;

endmodule
	
// OUTPUT Select Look Up Table
// Inputs: recovery references from each policy's output module
// Outputs: final signals for outputs
module F_LUT_Output_Edit (
		// Inputs (plant to controller) 
		input wire A_ptc_in,
		output reg A_ptc_out, // final
		

		// Outputs (controller to plant) 
		input wire B_ctp_in,
		output reg B_ctp_out, // final
		
		input reg [2:0] ab5_policy_AB5_output_recovery_ref,
		
		input wire clk
	);

	reg A = 0;
	reg B = 0;
	initial begin
		A_ptc_out = 0;
		B_ctp_out = 0;
	end

	// TODO: LUT
	always @(posedge clk) begin
		case({ ab5_policy_AB5_output_recovery_ref }) 
			3'b001: begin
				A = 1;
				B = 0;
				end
			3'b010: begin
				A = 1;
				B = 0;
				end
			3'b011: begin
				A = 1;
				B = 0;
				end
			3'b100: begin
				A = 1;
				B = 0;
				end
			3'b101: begin
				A = 1;
				B = 0;
				end
			3'b110: begin
				A = 0;
				B = 1;
				end
			3'b111: begin
				A = 0;
				B = 1;
				end

			default: begin 
					A = A_ptc_in;
					B = B_ctp_in;
				end
		endcase
		
		A_ptc_out = A;
		B_ctp_out = B;
	end


endmodule

module parallel_sim_FSM (
	input wire A_ptc_enf,
	output wire A_ptc_enf_out,
	output wire A_ptc_enf_trans,
	input wire B_ctp_enf,
	output wire B_ctp_enf_out,
	output wire B_ctp_enf_trans,
	input wire clk,
	output wire clk_input,
	output wire clk_output,
	output wire clk_transition,
	output wire [2:0] state_out
);
	reg [2:0] c_state = 0;

	reg c_in = 0;
	reg c_out = 0;
	reg c_trans = 0;
	reg A_enf = 0;
	reg B_enf = 0;

	reg A_trans = 0;
	reg B_trans = 0;

	always @(posedge clk)
	begin
		A_enf = 0;
		B_enf = 0;

		c_in = 0;
		c_out = 0;
		c_trans = 0;

		if (c_state == 3'b101) begin
			c_state = 0;
		end
		else begin
			c_state = c_state + 1;
		end

		case (c_state)
			3'b001: begin
				// Input
				c_in = 1;
			end
			3'b010: begin
				// Express Input 
				A_enf = A_ptc_enf;
				A_trans = A_ptc_enf;
				// Controller
			end
			3'b011: begin
				// Output
				c_out = 1;
			end
			3'b100: begin
				// Express Output
				B_enf = B_ctp_enf;
				B_trans = B_ctp_enf;
			end
			3'b101: begin
				// Transition

				// TODO: New signals here from A and B to pass to transition module

				c_trans = 1;
			end
		endcase

	end

	assign A_ptc_enf_out = A_enf;
	assign B_ctp_enf_out = B_enf;

	assign A_ptc_enf_trans = A_trans;
	assign B_ctp_enf_trans = B_trans;

	assign state_out = c_state;
	assign clk_input = c_in;
	assign clk_output = c_out;
	assign clk_transition = c_trans;

endmodule


module parallel_F_ab5(

		//inputs (plant to controller)
		A_ptc,
		A_ptc_out,
		A_ptc_out_ignore,
		A_ptc_out_temp,
		A_ptc_out_latched,
		A_ptc_out_trans,
		//OUTPUT_A_ptc_enf_final,
		
		//outputs (controller to plant)
		B_ctp,
		B_ctp_out,
		B_ctp_out_ignore,
		B_ctp_out_latched,
		B_ctp_out_trans,
		//OUTPUT_B_ctp_enf_final,
		
		//helper outputs
		//v_out,
		//ab5_policy_AB5_state_out,
		
		ab5_policy_AB5_input_recovery_ref,
		ab5_policy_AB5_output_recovery_ref,
		
		fsm_state,

		clk_input,
		clk_output,
		clk_transition,
		clk
	);

	input wire clk;

	output wire clk_input;
	output wire clk_output;
	output wire clk_transition;
	output wire [2:0] fsm_state;

	input wire A_ptc;
	output wire A_ptc_out;
	output wire A_ptc_out_temp;
	output wire A_ptc_out_latched;
	output wire A_ptc_out_ignore;
	output wire A_ptc_out_trans;
	
	input wire B_ctp;
	output wire B_ctp_out;
	output wire B_ctp_out_latched;
	output wire B_ctp_out_ignore;
	output wire B_ctp_out_trans;
	
	// Internal Variables
	wire [63:0] v;

	// States
	wire [1:0] ab5_policy_AB5_state;

	// Recovery References
	output wire [2:0] ab5_policy_AB5_input_recovery_ref;
	output wire [2:0] ab5_policy_AB5_output_recovery_ref;
	
	parallel_sim_FSM instance_parallel_sim_FSM(
		.A_ptc_enf(A_ptc_out),
		.A_ptc_enf_out(A_ptc_out_latched),
		.A_ptc_enf_trans(A_ptc_out_trans),
		.B_ctp_enf(B_ctp_out),
		.B_ctp_enf_out(B_ctp_out_latched),
		.B_ctp_enf_trans(B_ctp_out_trans),
		.clk(clk),
		.clk_input(clk_input),
		.clk_output(clk_output),
		.clk_transition(clk_transition),
		.state_out(fsm_state)
	);

	F_combinatorialVerilog_ab5_policy_AB5_input instance_policy_AB5_input(
		.ab5_policy_AB5_state_in(ab5_policy_AB5_state),
		.ab5_policy_AB5_input_recovery_ref(ab5_policy_AB5_input_recovery_ref),
		
		.A_ptc_in(A_ptc),
		
		.v(v),
		.clk(clk_input)
	);

	F_LUT_Output_Edit instance_LUT_Input_Edit(
		
		.A_ptc_in(A_ptc),
		.A_ptc_out(A_ptc_out),
		
		.B_ctp_in(B_ctp),
		.B_ctp_out(B_ctp_out_ignore),
		
		.ab5_policy_AB5_output_recovery_ref(ab5_policy_AB5_input_recovery_ref),
		
		.clk(clk_input)
	);

	F_combinatorialVerilog_ab5_policy_AB5_output instance_policy_AB5_output(
		
		.A_ptc_out(A_ptc_out_trans),
		

		
		.B_ctp_in(B_ctp),
		
		.ab5_policy_AB5_state_in(ab5_policy_AB5_state),
		.ab5_policy_AB5_output_recovery_ref(ab5_policy_AB5_output_recovery_ref),
		
		.v(v),
		.clk(clk_output)
	);

	F_LUT_Output_Edit instance_LUT_Output_Edit(
		
		.A_ptc_in(A_ptc_out_latched),
		.A_ptc_out(A_ptc_out_ignore),
		
		.B_ctp_in(B_ctp),
		.B_ctp_out(B_ctp_out),
		
		.ab5_policy_AB5_output_recovery_ref(ab5_policy_AB5_output_recovery_ref),
		
		.clk(clk_output)
	);

	F_combinatorialVerilog_ab5_policy_AB5_transition instance_policy_AB5_transition(
		
		.A_ptc_final(A_ptc_out_trans),
		
		
		.B_ctp_final(B_ctp_out_trans),
		
		
		.v_out(v),
		.ab5_policy_AB5_state_out(ab5_policy_AB5_state),
		.clk(clk_transition)
	);

	
endmodule

