package rtec

import (
	"text/template"

	"github.com/PRETgroup/goFB/goFB/stconverter"
)

const rteVerilogTemplate = `{{define "_policyIn"}}{{$block := .}}
	//input policies
	{{range $polI, $pol := $block.Policies}}{{$pfbEnf := getPolicyEnfInfo $block $polI}}
	{{if not $pfbEnf}}//{{$pol.Name}} is broken!
	{{else}}{{/* this is where the policy comes in */}}//INPUT POLICY {{$pol.Name}} BEGIN 
		case({{$block.Name}}_policy_{{$pol.Name}}_state)
		{{range $sti, $st := $pol.States}}` + "`" + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{$st.Name}}: begin
				{{range $tri, $tr := $pfbEnf.InputPolicy.GetViolationTransitions}}{{if eq $tr.Source $st.Name}}{{/*
				*/}}
				if ({{$cond := getVerilogECCTransitionCondition $block (compileExpression $tr.STGuard)}}{{$cond.IfCond}}) begin
					//transition {{$tr.Source}} -> {{$tr.Destination}} on {{$tr.Condition}}
					//select a transition to solve the problem
					{{$solution := $pfbEnf.SolveViolationTransition $tr true}}
					{{if $solution.Comment}}//{{$solution.Comment}}{{end}}
					{{range $soleI, $sole := $solution.Expressions}}{{$sol := getVerilogECCTransitionCondition $block (compileExpression $sole)}}{{$sol.IfCond}};
					{{end}}
				end{{end}}{{end}}
			end
			{{end}}
		endcase
	{{end}}
	//INPUT POLICY {{$pol.Name}} END
	{{end}}
{{end}}

{{define "_policyOut"}}{{$block := .}}
	//output policies
	{{range $polI, $pol := $block.Policies}}{{$pfbEnf := getPolicyEnfInfo $block $polI}}
	{{if not $pfbEnf}}//{{$pol.Name}} is broken!
	{{else}}{{/* this is where the policy comes in */}}//OUTPUT POLICY {{$pol.Name}} BEGIN 
		//advance timers
		{{range $varI, $var := $pfbEnf.OutputPolicy.GetDTimers}}
		{{$var.Name}} = {{$var.Name}} + 1;{{end}}
		
		case({{$block.Name}}_policy_{{$pol.Name}}_state)
		{{range $sti, $st := $pol.States}}` + "`" + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{$st.Name}}: begin
				{{range $tri, $tr := $pfbEnf.OutputPolicy.GetViolationTransitions}}{{if eq $tr.Source $st.Name}}{{/*
				*/}}
				if ({{$cond := getVerilogECCTransitionCondition $block (compileExpression $tr.STGuard)}}{{$cond.IfCond}}) begin
					//transition {{$tr.Source}} -> {{$tr.Destination}} on {{$tr.Condition}}
					//select a transition to solve the problem
					{{$solution := $pfbEnf.SolveViolationTransition $tr false}}
					{{if $solution.Comment}}//{{$solution.Comment}}{{end}}
					{{range $soleI, $sole := $solution.Expressions}}{{$sol := getVerilogECCTransitionCondition $block (compileExpression $sole)}}{{$sol.IfCond}};
					{{end}}
				end {{end}}{{end}}
			end
			{{end}}
		endcase


		//select transition to advance state
		case({{$block.Name}}_policy_{{$pol.Name}}_state)
		{{range $sti, $st := $pol.States}}` + "`" + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{$st.Name}}: begin
				{{range $tri, $tr := $pfbEnf.OutputPolicy.GetNonViolationTransitions}}{{if eq $tr.Source $st.Name}}{{/*
				*/}}
				if ({{$cond := getVerilogECCTransitionCondition $block (compileExpression $tr.STGuard)}}{{$cond.IfCond}}) begin
					//transition {{$tr.Source}} -> {{$tr.Destination}} on {{$tr.Condition}}
					{{$block.Name}}_policy_{{$pol.Name}}_state = ` + "`" + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{$tr.Destination}};
					//set expressions
					{{range $exi, $ex := $tr.Expressions}}
					{{$ex.VarName}} = {{$ex.Value}};{{end}}
				end {{end}}{{end}}
			end
			{{end}}
		endcase
	{{end}}
	//OUTPUT POLICY {{$pol.Name}} END
	{{end}}
{{end}}

{{define "functionVerilog"}}{{$block := index .Functions .FunctionIndex}}{{$blocks := .Functions}}
//This file should be called F_{{$block.Name}}.v
//This is autogenerated code. Edit by hand at your peril!

//For each policy, we need define types for the state machines
{{range $polI, $pol := $block.Policies}}
{{if len $pol.States}}{{range $index, $state := $pol.States}}
` + "`" + `define POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{$state}} {{$index}}{{end}}{{else}}POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_unknown 0{{end}}
{{end}}

module F_{{$block.Name}} (
	//inputs (plant to controller){{range $index, $var := $block.InputVars}}
	input wire {{getVerilogWidthArrayForType $var.Type}} {{$var.Name}}_ptc_in,
	output wire {{getVerilogWidthArrayForType $var.Type}} {{$var.Name}}_ptc_out,
	{{end}}
	//outputs (controller to plant){{range $index, $var := $block.OutputVars}}
	input wire {{getVerilogWidthArrayForType $var.Type}} {{$var.Name}}_ctp_in,
	output wire {{getVerilogWidthArrayForType $var.Type}} {{$var.Name}}_ctp_out,
	{{end}}
	input wire CLOCK
);

//For each policy, we need a reg for the state machine
{{range $polI, $pol := $block.Policies}}reg {{getVerilogWidthArray (len $pol.States)}} {{$block.Name}}_policy_{{$pol.Name}}_state = 0;
{{end}}

{{range $index, $var := $block.InputVars}}
{{getVerilogType $var.Type}} {{$var.Name}} {{if $var.InitialValue}} = {{$var.InitialValue}}{{end}};
{{end}}{{range $index, $var := $block.OutputVars}}
{{getVerilogType $var.Type}} {{$var.Name}} {{if $var.InitialValue}} = {{$var.InitialValue}}{{end}};
{{end}}{{range $polI, $pol := $block.Policies}}
{{$pfbEnf := getPolicyEnfInfo $block $polI}}{{if not $pfbEnf}}//Policy is broken!{{else}}//internal vars
{{range $vari, $var := $pfbEnf.OutputPolicy.InternalVars}}{{getVerilogType $var.Type}} {{$var.Name}}{{if $var.InitialValue}} = {{$var.InitialValue}}{{end}};
{{end}}{{end}}{{end}}

	always@(posedge CLOCK) begin
		//capture synchronous inputs
	{{range $index, $var := $block.InputVars}}
		{{$var.Name}} = {{$var.Name}}_ptc_in;
	{{end}}
	{{range $index, $var := $block.OutputVars}}
		{{$var.Name}} = {{$var.Name}}_ctp_in;
	{{end}}
		{{if $block.Policies}}{{template "_policyIn" $block}}{{end}}
		{{if $block.Policies}}{{template "_policyOut" $block}}{{end}}
	end
	
	//emit outputs
{{range $index, $var := $block.InputVars}}
	assign {{$var.Name}}_ptc_out = {{$var.Name}};
{{end}}
{{range $index, $var := $block.OutputVars}}
	assign {{$var.Name}}_ctp_out = {{$var.Name}};
{{end}}


endmodule{{end}}`

var verilogTemplateFuncMap = template.FuncMap{
	"getVerilogECCTransitionCondition": getVerilogECCTransitionCondition,
	"getVerilogType":                   getVerilogType,
	"getPolicyEnfInfo":                 getPolicyEnfInfo,
	"getVerilogWidthArray":             getVerilogWidthArray,
	"getVerilogWidthArrayForType":      getVerilogWidthArrayForType,

	"compileExpression": stconverter.VerilogCompileExpression,
}

var verilogTemplates = template.Must(template.New("").Funcs(verilogTemplateFuncMap).Parse(rteVerilogTemplate))
