package rtec

import (
	"text/template"

	"github.com/PRETgroup/goFB/goFB/stconverter"
)

const rteVerilogParallelCompositionTemplate = `
{{define "functionVerilog"}}{{$block := index .Functions .FunctionIndex}}{{$blocks := .Functions}}{{$pbfPolicies := getAllPolicyEnfInfo $block}}
//This file should be called F_{{$block.Name}}.sv
//This is autogenerated code. Edit by hand at your peril!!!

//Warning: This is experimental parallel composition code.

{{range $polI, $pol := $block.Policies}}
	module F_combinatorialVerilog_{{$block.Name}}_policy_{{$pol.Name}}_input (
		
		//inputs (plant to controller){{range $index, $var := $block.InputVars}}
		input wire {{getVerilogWidthArrayForType $var.Type}} {{$var.Name}}_ptc_in,
		{{end}}
		{{$pfbEnf := index $pbfPolicies $polI}}{{if not $pfbEnf}}//Policy is broken!{{else}}// Internal Variables Input
		{{range $vari, $var := $pfbEnf.OutputPolicy.InternalVars}}{{if not $var.Constant}}input wire {{getVerilogWidthArrayForType $var.Type}} {{$var.Name}},{{end}}{{end}}{{end}}
		
		//helpful state output input var{{if $polI}},
		{{end}}
		input wire {{getVerilogWidthArray (add (len $pol.States) 1)}} {{$block.Name}}_policy_{{$pol.Name}}_state_in,
		
		// Recovery Reference
		output wire {{getVerilogWidthArray (getMaxRecoveryReference $pol)}} {{$block.Name}}_policy_{{$pol.Name}}_input_recovery_ref,

		input wire clk
		);

		//For each policy, we need define types for the state machines
		localparam
			{{if len $pol.States}}{{range $index, $state := $pol.States}}` + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{$state}} = {{$index}},
			{{end}}{{else}}POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_unknown 0 {{end}}` + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_violation = {{if len $pol.States}}{{len $pol.States}};{{else}}1;{{end}}

		{{range $index, $var := $block.InputVars}}
		{{getVerilogType $var.Type}}{{$var.Name}} {{if $var.InitialValue}}/* = {{$var.InitialValue}}*/{{else}}= 0{{end}};
		{{end}}
		// Recovery ref declare and init
		reg {{getVerilogWidthArray (getMaxRecoveryReference $pol)}} recoveryReference = 0;

		initial begin
			recoveryReference = 0;
		end

		always @({{$block.Name}}_policy_{{$pol.Name}}_state_in, {{range $index, $var := $block.InputVars}}{{$var.Name}}_ptc_in,{{end}} clk) begin
			
			// Default no change to inputs (transparency) {{range $index, $var := $block.InputVars}}
			{{$var.Name}} = {{$var.Name}}_ptc_in;
			{{end}}
			recoveryReference = 0;

			{{if $block.Policies}}//input policies
			{{$pfbEnf := index $pbfPolicies $polI}}
			{{if not $pfbEnf}}//{{$pol.Name}} is broken!
			{{else}}{{/* this is where the policy comes in */}}	//INPUT POLICY {{$pol.Name}} BEGIN 
				case({{$block.Name}}_policy_{{$pol.Name}}_state_in)
					{{range $sti, $st := $pol.States}}` + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{$st.Name}}: begin
						// Default location recovery reference
						{{range $tri, $tr := $pfbEnf.OutputPolicy.GetTransitionsForSource $st.Name}}{{$cond := getVerilogECCTransitionCondition $block (compileExpression $tr.STGuard)}}{{if isDefault $cond.IfCond}}recoveryReference = {{$tr.RecoveryReference}};{{end}}{{end}}
						{{range $tri, $tr := $pfbEnf.InputPolicy.GetViolationTransitions}}{{if eq $tr.Source $st.Name}}{{/*
						*/}}
						if ({{$cond := getVerilogECCTransitionCondition $block (compileExpression $tr.STGuard)}}{{$cond.IfCond}}) begin
							//transition {{$tr.Source}} -> {{$tr.Destination}} on {{$tr.Condition}}
							//select a transition to solve the problem
							{{$solution := $pfbEnf.SolveViolationTransition $tr true}}
							{{if $solution.Comment}}//{{$solution.Comment}}{{end}}
							{{range $soleI, $sole := $solution.Expressions}}{{$sol := getVerilogECCTransitionCondition $block (compileExpression $sole)}}{{$sol.IfCond}};
							{{end}}
							// Set recovery reference
							recoveryReference = {{$tr.RecoveryReference}};
						end{{end}}{{end}}
					end
					{{end}}
				endcase
			{{end}}
			//INPUT POLICY {{$pol.Name}} END{{end}}
		end
		assign {{$block.Name}}_policy_{{$pol.Name}}_input_recovery_ref = recoveryReference;

	endmodule

	module F_combinatorialVerilog_{{$block.Name}}_policy_{{$pol.Name}}_output (
		//(Final) inputs (plant to controller){{range $index, $var := $block.InputVars}}
		input wire {{getVerilogWidthArrayForType $var.Type}} {{$var.Name}}_ptc_out,
		{{end}}


		//outputs (controller to plant){{range $index, $var := $block.OutputVars}}
		input wire {{getVerilogWidthArrayForType $var.Type}} {{$var.Name}}_ctp_in,
		//output wire {{getVerilogWidthArrayForType $var.Type}} {{$var.Name}}_ctp_out,
		{{end}}

		{{$pfbEnf := index $pbfPolicies $polI}}{{if not $pfbEnf}}//Policy is broken!{{else}}// Internal Variables Input
		{{range $vari, $var := $pfbEnf.OutputPolicy.InternalVars}}{{if not $var.Constant}}input wire {{getVerilogWidthArrayForType $var.Type}} {{$var.Name}},{{end}}{{end}}{{end}}

		// State Input
		input wire {{getVerilogWidthArray (add (len $pol.States) 1)}} {{$block.Name}}_policy_{{$pol.Name}}_state_in,

		// Recovery Reference Output
		output wire {{getVerilogWidthArray (getMaxRecoveryReference $pol)}} {{$block.Name}}_policy_{{$pol.Name}}_output_recovery_ref,

		input wire clk

	);

		//For each policy, we need define types for the state machines
		localparam
			{{if len $pol.States}}{{range $index, $state := $pol.States}}` + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{$state}} = {{$index}},
			{{end}}{{else}}POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_unknown 0 {{end}}` + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_violation = {{if len $pol.States}}{{len $pol.States}};{{else}}1;{{end}}

		{{range $index, $var := $block.InputVars}}
		{{getVerilogType $var.Type}}{{$var.Name}} {{if $var.InitialValue}}/* = {{$var.InitialValue}}*/{{else}}= 0{{end}};
		{{end}}{{range $index, $var := $block.OutputVars}}
		{{getVerilogType $var.Type}}{{$var.Name}} {{if $var.InitialValue}}/* = {{$var.InitialValue}}*/{{else}}= 0{{end}};
		{{end}}
		// Recovery ref declare and init
		reg {{getVerilogWidthArray (getMaxRecoveryReference $pol)}} recoveryReference = 0;

		initial begin
			recoveryReference = 0;
		end

		always @({{$block.Name}}_policy_{{$pol.Name}}_state_in, {{range $index, $var := $block.OutputVars}}{{$var.Name}}_ctp_in,{{end}} clk) begin
			// Default no change to inputs/outputs (transparency) {{range $index, $var := $block.InputVars}}
			{{$var.Name}} = {{$var.Name}}_ptc_out;
			{{end}}
			{{range $index, $var := $block.OutputVars}}{{$var.Name}} = {{$var.Name}}_ctp_in;
			{{end}}
			recoveryReference = 0;

			//output policies
			{{if not $pfbEnf}}//{{$pol.Name}} is broken!
			{{else}}{{/* this is where the policy comes in */}}	//OUTPUT POLICY {{$pol.Name}} BEGIN 
				
				case({{$block.Name}}_policy_{{$pol.Name}}_state_in)
					{{range $sti, $st := $pol.States}}` + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{$st.Name}}: begin
						// Default location recovery reference
						{{range $tri, $tr := $pfbEnf.OutputPolicy.GetTransitionsForSource $st.Name}}{{$cond := getVerilogECCTransitionCondition $block (compileExpression $tr.STGuard)}}{{if isDefault $cond.IfCond}}recoveryReference = {{$tr.RecoveryReference}};{{end}}{{end}}
						{{range $tri, $tr := $pfbEnf.OutputPolicy.GetViolationTransitions}}{{if eq $tr.Source $st.Name}}{{/**/}}
						if ({{$cond := getVerilogECCTransitionCondition $block (compileExpression $tr.STGuard)}}{{$cond.IfCond}}) begin
							//transition {{$tr.Source}} -> {{$tr.Destination}} on {{$tr.Condition}}
							//select a transition to solve the problem
							{{$solution := $pfbEnf.SolveViolationTransition $tr false}}
							{{if $solution.Comment}}//{{$solution.Comment}}{{end}}
							{{range $soleI, $sole := $solution.Expressions}}{{$sol := getVerilogECCTransitionCondition $block (compileExpression $sole)}}{{$sol.IfCond}};
							{{end}}
							// Set recovery reference
							recoveryReference = {{$tr.RecoveryReference}};

						end {{end}}{{end}}
					end
					{{end}}
				endcase
			{{end}}
			//OUTPUT POLICY {{$pol.Name}} END
		end

		assign {{$block.Name}}_policy_{{$pol.Name}}_output_recovery_ref = recoveryReference;

	endmodule

	module F_combinatorialVerilog_{{$block.Name}}_policy_{{$pol.Name}}_transition (
		// Final inputs (plant to controller) {{range $index, $var := $block.InputVars}}
		input wire {{$var.Name}}_ptc_final,
		{{end}}
		// Final outputs (controller to plant) {{range $index, $var := $block.OutputVars}}
		input wire {{$var.Name}}_ctp_final,
		{{end}}

		{{$pfbEnf := index $pbfPolicies $polI}}{{if not $pfbEnf}}//Policy is broken!{{else}}// Internal Variables Output
		{{range $vari, $var := $pfbEnf.OutputPolicy.InternalVars}}{{if not $var.Constant}}output wire {{getVerilogWidthArrayForType $var.Type}} {{$var.Name}}_out,{{end}}{{end}}{{end}}

		// State Output
		output wire {{getVerilogWidthArray (add (len $pol.States) 1)}} {{$block.Name}}_policy_{{$pol.Name}}_state_out,

		input wire clk
		);
		
		//For each policy, we need define types for the state machines
		localparam
			{{if len $pol.States}}{{range $index, $state := $pol.States}}` + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{$state}} = {{$index}},
			{{end}}{{else}}POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_unknown 0 {{end}}` + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_violation = {{if len $pol.States}}{{len $pol.States}};{{else}}1;{{end}}
		
		// Maybe remove these? {{range $index, $var := $block.InputVars}}
		{{getVerilogType $var.Type}}{{$var.Name}} {{if $var.InitialValue}}/* = {{$var.InitialValue}}*/{{else}}= 0{{end}};
		{{end}}{{range $index, $var := $block.OutputVars}}
		{{getVerilogType $var.Type}}{{$var.Name}} {{if $var.InitialValue}}/* = {{$var.InitialValue}}*/{{else}}= 0{{end}};
		{{end}}
		//internal vars
		{{range $vari, $var := $pol.InternalVars}}{{if $var.Constant}}wire {{getVerilogWidthArrayForType $var.Type}} {{$var.Name}} = {{$var.InitialValue}} {{else}}{{getVerilogType $var.Type}} {{$var.Name}} = 0{{if $var.InitialValue}}/* = {{$var.InitialValue}}*/{{end}}{{end}};
		{{if not $var.Constant}}reg reset_{{$var.Name}};{{end}}
		{{end}}

		//For each policy, we need a reg for the state machine
		reg {{getVerilogWidthArray (add (len $pol.States) 1)}} {{$block.Name}}_policy_{{$pol.Name}}_c_state = 0;
		reg {{getVerilogWidthArray (add (len $pol.States) 1)}} {{$block.Name}}_policy_{{$pol.Name}}_n_state = 0;

		initial begin
			{{$block.Name}}_policy_{{$pol.Name}}_c_state = 0;
			{{$block.Name}}_policy_{{$pol.Name}}_n_state = 0;
		end

		always @(posedge clk)
		begin
			{{$block.Name}}_policy_{{$pol.Name}}_c_state = {{$block.Name}}_policy_{{$pol.Name}}_n_state;

			//increment timers/clocks
			{{$pfbEnf := index $pbfPolicies $polI}}{{if not $pfbEnf}}//Policy is broken!{{else}}//internal vars
			{{range $vari, $var := $pfbEnf.OutputPolicy.InternalVars}}{{if not $var.Constant}}if (reset_{{$var.Name}} === 1) begin
				{{$var.Name}} = 0;
			end else begin
				{{$var.Name}} = {{$var.Name}}{{if $var.IsDTimer}} + 1;
			end {{end}}{{end}}{{end}}{{end}}
		end

		always @* begin
			{{range $index, $var := $block.InputVars}}
			{{$var.Name}} = {{$var.Name}}_ptc_final; {{end}}
			{{range $index, $var := $block.OutputVars}}
			{{$var.Name}} = {{$var.Name}}_ctp_final; {{end}}

			// Default no location change
			{{$block.Name}}_policy_{{$pol.Name}}_n_state = {{$block.Name}}_policy_{{$pol.Name}}_c_state;
			
			{{$pfbEnf := index $pbfPolicies $polI}}{{if not $pfbEnf}}//Policy is broken!{{else}}// Default no clock reset
			{{range $vari, $var := $pfbEnf.OutputPolicy.InternalVars}}{{if not $var.Constant}}reset_{{$var.Name}} = 0;{{end}}{{end}}{{end}}

			//transTaken_{{$block.Name}}_policy_{{$pol.Name}} = 0;
			//select transition to advance state
			case({{$block.Name}}_policy_{{$pol.Name}}_c_state)
				{{range $sti, $st := $pol.States}}` + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{$st.Name}}: begin
					{{range $tri, $tr := $pfbEnf.OutputPolicy.GetTransitionsForSource $st.Name}}{{/*
					*/}}
					{{$cond := getVerilogECCTransitionCondition $block (compileExpression $tr.STGuard)}}{{if not (isDefault $cond.IfCond)}}{{if $tri}}else{{end}} if ({{$cond := getVerilogECCTransitionCondition $block (compileExpression $tr.STGuard)}}{{$cond.IfCond}}) begin
						//transition {{$tr.Source}} -> {{$tr.Destination}} on {{$tr.Condition}}
						{{$block.Name}}_policy_{{$pol.Name}}_n_state = ` + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{$tr.Destination}};
						//set expressions
						{{range $exi, $ex := $tr.Expressions}}{{if not (equal_str ($ex.Value) "0")}}
						{{$ex.VarName}} = {{$ex.Value}};{{else}}reset_{{$ex.VarName}} = 1;{{end}}{{end}}
						//transTaken_{{$block.Name}}_policy_{{$pol.Name}} = 1;
					end {{end}} {{end}} else begin
						//only possible in a violation
						{{$block.Name}}_policy_{{$pol.Name}}_n_state = ` + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_violation;
						//transTaken_{{$block.Name}}_policy_{{$pol.Name}} = 1;
					end
				end
				{{end}}
				default begin
					//if we are here, we're in the violation state
					//the violation state permanently stays in violation
					{{$block.Name}}_policy_{{$pol.Name}}_n_state = ` + `POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_violation;
					//transTaken_{{$block.Name}}_policy_{{$pol.Name}} = 1;
				end
			endcase

		end

		//emit state/time inputs
		assign {{$block.Name}}_policy_{{$pol.Name}}_state_out =  {{$block.Name}}_policy_{{$pol.Name}}_c_state;
		{{$pfbEnf := index $pbfPolicies $polI}}{{if not $pfbEnf}}//Policy is broken!{{else}}//internal vars
		{{range $vari, $var := $pfbEnf.OutputPolicy.InternalVars}}{{if not $var.Constant}}assign {{$var.Name}}_out = {{$var.Name}};{{end}}
		{{end}}{{end}}

	endmodule

	{{end}}

// NOTE: Input Select LUT uses Output LUT :)
// INPUT Select Look Up Table
// Inputs: recovery references from each policy's input module
// Outputs: final signals for inputs
//module F_LUT_Input_Edit (
		// Inputs (plant to controller) {{range $index, $var := $block.InputVars}}
		//input wire {{$var.Name}}_ptc_in,
		//output wire {{$var.Name}}_ptc_out, // final
		{{end}}
		{{range $polI, $pol := $block.Policies}}//input wire {{getVerilogWidthArray (getMaxRecoveryReference $pol)}} {{$block.Name}}_policy_{{$pol.Name}}_input_recovery_ref,
		{{end}}
		//input wire clk
	//);
	
//endmodule
	
// OUTPUT Select Look Up Table
// Inputs: recovery references from each policy's output module
// Outputs: final signals for outputs
module F_LUT_Output_Edit (
		// Inputs (plant to controller) {{range $index, $var := $block.InputVars}}
		input wire {{$var.Name}}_ptc_in,
		output wire {{$var.Name}}_ptc_out, // final
		{{end}}

		// Outputs (controller to plant) {{range $index, $var := $block.OutputVars}}
		input wire {{$var.Name}}_ctp_in,
		output wire {{$var.Name}}_ctp_out, // final
		{{end}}
		{{range $polI, $pol := $block.Policies}}input wire {{getVerilogWidthArray (getMaxRecoveryReference $pol)}} {{$block.Name}}_policy_{{$pol.Name}}_output_recovery_ref,
		{{end}}
		input wire clk
	);

	{{range $index, $var := $block.InputVars}}reg {{$var.Name}} = 0;
	{{end}}{{range $index, $var := $block.OutputVars}}reg {{$var.Name}} = 0;
	{{end}}
	
	//initial begin
		{{range $index, $var := $block.InputVars}}// {{$var.Name}}_ptc_out = 0;{{end}}
		{{range $index, $var := $block.OutputVars}}// {{$var.Name}}_ctp_out = 0;{{end}}
	//end

	// LUT
	always @(posedge clk) begin
		// Default to original signal (to preserve transparency)
		{{range $index, $var := $block.InputVars}}{{$var.Name}} = {{$var.Name}}_ptc_in;
		{{end}}{{range $index, $var := $block.OutputVars}}{{$var.Name}} = {{$var.Name}}_ctp_in;
		{{end}}

		case({ {{range $polI, $pol := $block.Policies}}{{if not (equal $polI 0)}}, {{end}}{{$block.Name}}_policy_{{$pol.Name}}_output_recovery_ref{{end}} }) 
			{{getLUT $block.Name}}
			default: begin {{range $index, $var := $block.InputVars}}
					{{$var.Name}} = {{$var.Name}}_ptc_in;{{end}}{{range $index, $var := $block.OutputVars}}
					{{$var.Name}} = {{$var.Name}}_ctp_in;{{end}}
				end
		endcase
		{{range $index, $var := $block.InputVars}}
		//{{$var.Name}}_ptc_out = {{$var.Name}};{{end}}{{range $index, $var := $block.OutputVars}}
		//{{$var.Name}}_ctp_out = {{$var.Name}};{{end}}

	end
	{{range $index, $var := $block.InputVars}}
	assign {{$var.Name}}_ptc_out = {{$var.Name}};{{end}}{{range $index, $var := $block.OutputVars}}
	assign {{$var.Name}}_ctp_out = {{$var.Name}};{{end}}
	
endmodule

module parallel_sim_FSM ({{range $index, $var := $block.InputVars}}
	input wire {{$var.Name}}_ptc_enf,
	output wire {{$var.Name}}_ptc_enf_out,
	output wire {{$var.Name}}_ptc_enf_trans,{{end}}
	{{range $index, $var := $block.OutputVars}}
	input wire {{$var.Name}}_ctp_enf,
	output wire {{$var.Name}}_ctp_enf_out,
	output wire {{$var.Name}}_ctp_enf_trans,
	{{end}}
	input wire clk,
	output wire clk_input,
	output wire clk_output,
	output wire clk_transition,
	output wire [2:0] state_out
);
	reg [2:0] c_state = 0;

	reg c_in = 0;
	reg c_out = 0;
	reg c_trans = 0;
	{{range $index, $var := $block.InputVars}}
	reg {{$var.Name}}_enf = 0;
	reg {{$var.Name}}_trans = 0;{{end}}
	{{range $index, $var := $block.OutputVars}}
	reg {{$var.Name}}_enf = 0;
	reg {{$var.Name}}_trans = 0;
	{{end}}
	always @(posedge clk)
	begin{{range $index, $var := $block.InputVars}}
		{{$var.Name}}_enf = 0;
		{{$var.Name}}_trans = 0;
		{{end}}{{range $index, $var := $block.OutputVars}}
		{{$var.Name}}_enf = 0;
		{{$var.Name}}_trans = 0;
		{{end}}
		c_in = 0;
		c_out = 0;
		c_trans = 0;

		if (c_state == 3'b101) begin
			c_state = 0;
		end
		else begin
			c_state = c_state + 1;
		end

		case (c_state)
		3'b001: begin
			// Input
			c_in = 1;
		end
		3'b010: begin
			// Express Input 
			{{range $index, $var := $block.InputVars}}
			{{$var.Name}}_enf = {{$var.Name}}_ptc_enf;
			{{$var.Name}}_trans = {{$var.Name}}_ptc_enf;{{end}}

			// Controller
		end
		3'b011: begin
			// Output
			c_out = 1;
		end
		3'b100: begin
			// Express Output
			{{range $index, $var := $block.OutputVars}}
			{{$var.Name}}_enf = {{$var.Name}}_ctp_enf;
			{{$var.Name}}_trans = {{$var.Name}}_ctp_enf;{{end}}

		end
		3'b101: begin
			// Transition
			c_trans = 1;
		end
	endcase

	end
	{{range $index, $var := $block.InputVars}}
	assign {{$var.Name}}_ptc_enf_out = {{$var.Name}}_enf;
	assign {{$var.Name}}_ptc_enf_trans = {{$var.Name}}_trans;{{end}}
	{{range $index, $var := $block.OutputVars}}
	assign {{$var.Name}}_ctp_enf_out = {{$var.Name}}_enf;
	assign {{$var.Name}}_ctp_enf_trans = {{$var.Name}}_trans;{{end}}

	assign state_out = c_state;
	assign clk_input = c_in;
	assign clk_output = c_out;
	assign clk_transition = c_trans;

endmodule

module parallel_F_{{$block.Name}}(

		//inputs (plant to controller){{range $index, $var := $block.InputVars}}
		{{$var.Name}}_ptc,
		{{$var.Name}}_ptc_out,
		{{$var.Name}}_ptc_out_ignore,
		{{$var.Name}}_ptc_out_latched,
		{{$var.Name}}_ptc_out_trans,
		//OUTPUT_{{$var.Name}}_ptc_enf_final,{{end}}
		
		//outputs (controller to plant){{range $index, $var := $block.OutputVars}}
		{{$var.Name}}_ctp,
		{{$var.Name}}_ctp_out,
		{{$var.Name}}_ctp_out_ignore,
		{{$var.Name}}_ctp_out_latched,
		{{$var.Name}}_ctp_out_trans,
		//OUTPUT_{{$var.Name}}_ctp_enf_final,{{end}}
		
		//helper outputs{{range $polI, $pol := $block.Policies}}{{range $vari, $var := $pol.InternalVars}}{{if not $var.Constant}}
		//{{$var.Name}}_out,
		{{end}}{{end}}{{if $polI}}{{end}}//{{$block.Name}}_policy_{{$pol.Name}}_state_out,
		
		{{$block.Name}}_policy_{{$pol.Name}}_input_recovery_ref,
		{{$block.Name}}_policy_{{$pol.Name}}_output_recovery_ref,
		{{end}}
		fsm_state,

		clk_input,
		clk_output,
		clk_transition,
		clk
	);

	input wire clk;

	output wire clk_input;
	output wire clk_output;
	output wire clk_transition;
	output wire [2:0] fsm_state;
	{{range $index, $var := $block.InputVars}}
	input wire {{$var.Name}}_ptc;
	output wire {{$var.Name}}_ptc_out;
	output wire {{$var.Name}}_ptc_out_latched;
	output wire {{$var.Name}}_ptc_out_ignore;
	output wire {{$var.Name}}_ptc_out_trans;{{end}}
	{{range $index, $var := $block.OutputVars}}
	input wire {{$var.Name}}_ctp;
	output wire {{$var.Name}}_ctp_out;
	output wire {{$var.Name}}_ctp_out_latched;
	output wire {{$var.Name}}_ctp_out_ignore;
	output wire {{$var.Name}}_ctp_out_trans;{{end}}
	{{range $polI, $pol := $block.Policies}}
	{{$pfbEnf := index $pbfPolicies $polI}}{{if not $pfbEnf}}//Policy is broken!{{else}}// Internal Variables
	{{range $vari, $var := $pfbEnf.OutputPolicy.InternalVars}}{{if not $var.Constant}}wire {{getVerilogWidthArrayForType $var.Type}} {{$var.Name}};{{end}}{{end}}{{end}}

	// States
	wire {{getVerilogWidthArray (add (len $pol.States) 1)}} {{$block.Name}}_policy_{{$pol.Name}}_state;

	// Recovery References
	output wire {{getVerilogWidthArray (getMaxRecoveryReference $pol)}} {{$block.Name}}_policy_{{$pol.Name}}_input_recovery_ref;
	output wire {{getVerilogWidthArray (getMaxRecoveryReference $pol)}} {{$block.Name}}_policy_{{$pol.Name}}_output_recovery_ref;
	{{end}}
	parallel_sim_FSM instance_parallel_sim_FSM({{range $index, $var := $block.InputVars}}
		.{{$var.Name}}_ptc_enf({{$var.Name}}_ptc_out),
		.{{$var.Name}}_ptc_enf_out({{$var.Name}}_ptc_out_latched),
		.{{$var.Name}}_ptc_enf_trans({{$var.Name}}_ptc_out_trans),{{end}}
		{{range $index, $var := $block.OutputVars}}
		.{{$var.Name}}_ctp_enf({{$var.Name}}_ctp_out),
		.{{$var.Name}}_ctp_enf_out({{$var.Name}}_ctp_out_latched),
		.{{$var.Name}}_ctp_enf_trans({{$var.Name}}_ctp_out_trans),{{end}}
		
		.clk(clk),
		.clk_input(clk_input),
		.clk_output(clk_output),
		.clk_transition(clk_transition),
		.state_out(fsm_state)
	);
	{{range $polI, $pol := $block.Policies}}
	F_combinatorialVerilog_{{$block.Name}}_policy_{{$pol.Name}}_input instance_policy_{{$pol.Name}}_input(
		.{{$block.Name}}_policy_{{$pol.Name}}_state_in({{$block.Name}}_policy_{{$pol.Name}}_state),
		.{{$block.Name}}_policy_{{$pol.Name}}_input_recovery_ref({{$block.Name}}_policy_{{$pol.Name}}_input_recovery_ref),
		{{range $index, $var := $block.InputVars}}
		.{{$var.Name}}_ptc_in({{$var.Name}}_ptc),{{end}}
		{{$pfbEnf := index $pbfPolicies $polI}}{{if not $pfbEnf}}//Policy is broken!{{else}}
		{{range $vari, $var := $pfbEnf.OutputPolicy.InternalVars}}{{if not $var.Constant}}.{{$var.Name}}({{$var.Name}}),{{end}}{{end}}{{end}}
		.clk(clk_input)
	);
	{{end}}
	F_LUT_Output_Edit instance_LUT_Input_Edit(
		{{range $index, $var := $block.InputVars}}
		.{{$var.Name}}_ptc_in({{$var.Name}}_ptc),
		.{{$var.Name}}_ptc_out({{$var.Name}}_ptc_out),{{end}}
		{{range $index, $var := $block.OutputVars}}
		.{{$var.Name}}_ctp_in({{$var.Name}}_ctp),
		.{{$var.Name}}_ctp_out({{$var.Name}}_ctp_out_ignore),{{end}}
		{{range $polI, $pol := $block.Policies}}
		.{{$block.Name}}_policy_{{$pol.Name}}_output_recovery_ref({{$block.Name}}_policy_{{$pol.Name}}_input_recovery_ref),
		{{end}}
		.clk(clk_input)
	);
	{{range $polI, $pol := $block.Policies}}
	F_combinatorialVerilog_{{$block.Name}}_policy_{{$pol.Name}}_output instance_policy_{{$pol.Name}}_output(
		{{range $index, $var := $block.InputVars}}
		.{{$var.Name}}_ptc_out({{$var.Name}}_ptc_out_trans),
		{{end}}

		{{range $index, $var := $block.OutputVars}}
		.{{$var.Name}}_ctp_in({{$var.Name}}_ctp),
		{{end}}
		.{{$block.Name}}_policy_{{$pol.Name}}_state_in({{$block.Name}}_policy_{{$pol.Name}}_state),
		.{{$block.Name}}_policy_{{$pol.Name}}_output_recovery_ref({{$block.Name}}_policy_{{$pol.Name}}_output_recovery_ref),
		{{$pfbEnf := index $pbfPolicies $polI}}{{if not $pfbEnf}}//Policy is broken!{{else}}
		{{range $vari, $var := $pfbEnf.OutputPolicy.InternalVars}}{{if not $var.Constant}}.{{$var.Name}}({{$var.Name}}),{{end}}{{end}}{{end}}
		.clk(clk_output)
	);
	{{end}}
	F_LUT_Output_Edit instance_LUT_Output_Edit(
		{{range $index, $var := $block.InputVars}}
		.{{$var.Name}}_ptc_in({{$var.Name}}_ptc_out_latched),
		.{{$var.Name}}_ptc_out({{$var.Name}}_ptc_out_ignore),{{end}}
		{{range $index, $var := $block.OutputVars}}
		.{{$var.Name}}_ctp_in({{$var.Name}}_ctp),
		.{{$var.Name}}_ctp_out({{$var.Name}}_ctp_out),{{end}}
		{{range $polI, $pol := $block.Policies}}
		.{{$block.Name}}_policy_{{$pol.Name}}_output_recovery_ref({{$block.Name}}_policy_{{$pol.Name}}_output_recovery_ref),
		{{end}}
		.clk(clk_output)
	);
	{{range $polI, $pol := $block.Policies}}
	F_combinatorialVerilog_{{$block.Name}}_policy_{{$pol.Name}}_transition instance_policy_{{$pol.Name}}_transition(
		{{range $index, $var := $block.InputVars}}
		.{{$var.Name}}_ptc_final({{$var.Name}}_ptc_out_trans),
		{{end}}
		{{range $index, $var := $block.OutputVars}}
		.{{$var.Name}}_ctp_final({{$var.Name}}_ctp_out_trans),
		{{end}}
		{{$pfbEnf := index $pbfPolicies $polI}}{{if not $pfbEnf}}//Policy is broken!{{else}}
		{{range $vari, $var := $pfbEnf.OutputPolicy.InternalVars}}{{if not $var.Constant}}.{{$var.Name}}_out({{$var.Name}}),{{end}}{{end}}{{end}}
		.{{$block.Name}}_policy_{{$pol.Name}}_state_out({{$block.Name}}_policy_{{$pol.Name}}_state),
		.clk(clk_transition)
	);
	{{end}}

endmodule

{{end}}


`

var verilogParallelCompositionTemplateFuncMap = template.FuncMap{
	"getVerilogECCTransitionCondition": getVerilogECCTransitionCondition,
	"getVerilogType":                   getVerilogType,
	"getPolicyEnfInfo":                 getPolicyEnfInfo,
	"getAllPolicyEnfInfo":              getAllPolicyEnfInfo,
	"getVerilogWidthArray":             getVerilogWidthArray,
	"getVerilogWidthArrayForType":      getVerilogWidthArrayForType,
	"add1IfClock":                      add1IfClock,
	"isDefault":                        isDefault,
	"getMaxRecoveryReference":          getMaxRecoveryReference,
	"getLUT":                           getLUT,

	"compileExpression": stconverter.VerilogCompileExpression,

	"add":       add,
	"subtract":  subtract,
	"equal":     equal,
	"equal_str": equal_str,
}

var verilogParallelCompositionTemplates = template.Must(template.New("").Funcs(verilogParallelCompositionTemplateFuncMap).Parse(rteVerilogParallelCompositionTemplate))
