package rtec

import "text/template"

const rtecTemplate = `{{define "_policyIn"}}{{$block := .}}
	//input policies
	{{range $polI, $pol := $block.Policies}}{{$pfbEnf := getPolicyEnfInfo $block $polI}}
	{{if not $pfbEnf}}//{{$pol.Name}} is broken!
	{{else}}{{/* this is where the policy comes in */}}//INPUT POLICY {{$pol.Name}} BEGIN 
		switch(me->_policy_{{$pol.Name}}_state) {
			{{range $sti, $st := $pol.States}}case POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{$st.Name}}:
				{{range $tri, $tr := $pfbEnf.InputPolicy.GetViolationTransitions}}{{if eq $tr.Source $st.Name}}{{/*
				*/}}
				if({{$cond := getCECCTransitionCondition $block $tr.Condition}}{{$cond.IfCond}}) {
					//transition {{$tr.Source}} -> {{$tr.Destination}} on {{$tr.Condition}}
					//select a transition to solve the problem
					{{$solution := $pfbEnf.SolveViolationTransition $tr true}}
					{{if $solution.Comment}}//{{$solution.Comment}}{{end}}
					{{range $soleI, $sole := $solution.Expressions}}{{$sol := getCECCTransitionCondition $block $sole}}{{$sol.IfCond}};
					{{end}}
				} {{end}}{{end}}
				
				break;

			{{end}}
		}
	{{end}}
	//INPUT POLICY {{$pol.Name}} END
	{{end}}
{{end}}

{{define "_policyOut"}}{{$block := .}}
	//output policies
	{{range $polI, $pol := $block.Policies}}{{$pfbEnf := getPolicyEnfInfo $block $polI}}
	{{if not $pfbEnf}}//{{$pol.Name}} is broken!
	{{else}}{{/* this is where the policy comes in */}}//OUTPUT POLICY {{$pol.Name}} BEGIN 
		switch(me->_policy_{{$pol.Name}}_state) {
			{{range $sti, $st := $pol.States}}case POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{$st.Name}}:
				{{range $tri, $tr := $pfbEnf.OutputPolicy.GetViolationTransitions}}{{if eq $tr.Source $st.Name}}{{/*
				*/}}
				if({{$cond := getCECCTransitionCondition $block $tr.Condition}}{{$cond.IfCond}}) {
					//transition {{$tr.Source}} -> {{$tr.Destination}} on {{$tr.Condition}}
					//select a transition to solve the problem
					{{$solution := $pfbEnf.SolveViolationTransition $tr false}}
					{{if $solution.Comment}}//{{$solution.Comment}}{{end}}
					{{range $soleI, $sole := $solution.Expressions}}{{$sol := getCECCTransitionCondition $block $sole}}{{$sol.IfCond}};
					{{end}}
				} {{end}}{{end}}

				break;

			{{end}}
		}

		//advance timers
		{{range $varI, $var := $pfbEnf.OutputPolicy.GetDTimers}}
		me->{{$var.Name}}++;{{end}}

		//select transition to advance state
		switch(me->_policy_{{$pol.Name}}_state) {
			{{range $sti, $st := $pol.States}}case POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{$st.Name}}:
				{{range $tri, $tr := $pfbEnf.OutputPolicy.GetNonViolationTransitions}}{{if eq $tr.Source $st.Name}}{{/*
				*/}}
				if({{$cond := getCECCTransitionCondition $block $tr.Condition}}{{$cond.IfCond}}) {
					//transition {{$tr.Source}} -> {{$tr.Destination}} on {{$tr.Condition}}
					me->_policy_{{$pol.Name}}_state = POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{$tr.Destination}};
					//set expressions
					{{range $exi, $ex := $tr.Expressions}}
					me->{{$ex.VarName}} = {{$ex.Value}};{{end}}
				} {{end}}{{end}}
				
				break;

			{{end}}
		}
	{{end}}
	//OUTPUT POLICY {{$pol.Name}} END
	{{end}}
{{end}}

{{define "functionH"}}{{$block := index .Functions .FunctionIndex}}{{$blocks := .Functions}}
//This file should be called F_{{$block.Name}}.h
//This is autogenerated code. Edit by hand at your peril!

#include <stdint.h>
#include <stdbool.h>

//the dtimer_t type
typedef uint64_t dtimer_t;

//For each policy, we need an enum type for the state machine
{{range $polI, $pol := $block.Policies}}
enum {{$block.Name}}_policy_{{$pol.Name}}_states { {{if len $pol.States}}{{range $index, $state := $pol.States}}
	POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{$state}}{{if not $index}}, {{end}}{{end}}{{else}}POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_unknown{{end}} 
};
{{end}}

//Inputs to the function {{$block.Name}}
typedef struct {
	{{range $index, $var := $block.InputVars}}{{$var.Type}} {{$var.Name}}{{if $var.ArraySize}}[{{$var.ArraySize}}]{{end}};
	{{end}}
} inputs_{{$block.Name}}_t;

//Outputs from the function {{$block.Name}}
typedef struct {
	{{range $index, $var := $block.OutputVars}}{{$var.Type}} {{$var.Name}}{{if $var.ArraySize}}[{{$var.ArraySize}}]{{end}};
	{{end}}
} outputs_{{$block.Name}}_t;

//enforcer state and vars:
typedef struct {
	{{range $polI, $pol := $block.Policies}}enum {{$block.Name}}_policy_{{$pol.Name}}_states _policy_{{$pol.Name}}_state;
	{{$pfbEnf := getPolicyEnfInfo $block $polI}}{{if not $pfbEnf}}//Policy is broken!{{else}}//internal vars
	{{range $vari, $var := $pfbEnf.OutputPolicy.InternalVars}}{{$var.Type}} {{$var.Name}}{{if $var.ArraySize}}[{{$var.ArraySize}}]{{end}};
	{{end}}{{end}}
	{{end}}
} enforcervars_{{$block.Name}}_t;

//This function is provided in "F_{{$block.Name}}.c"
//It sets up the variable structures to their initial values
void {{$block.Name}}_init_all_vars(enforcervars_{{$block.Name}}_t* me, inputs_{{$block.Name}}_t* inputs, outputs_{{$block.Name}}_t* outputs);

//This function is provided in "F_{{$block.Name}}.c"
//It will run the synthesised enforcer and call the controller function
void {{$block.Name}}_run_via_enforcer(enforcervars_{{$block.Name}}_t* me, inputs_{{$block.Name}}_t inputs, outputs_{{$block.Name}}_t* outputs);

//This function is provided from the user
//It is the controller function
extern void {{$block.Name}}_run(inputs_{{$block.Name}}_t inputs, outputs_{{$block.Name}}_t* outputs);
{{end}}

{{define "functionC"}}{{$block := index .Functions .FunctionIndex}}{{$blocks := .Functions}}
//This file should be called F_{{$block.Name}}.c
//This is autogenerated code. Edit by hand at your peril!
#include "F_{{$block.Name}}.h"

void {{$block.Name}}_init_all_vars(enforcervars_{{$block.Name}}_t* me, inputs_{{$block.Name}}_t* inputs, outputs_{{$block.Name}}_t* outputs) {
	//set any input vars with default values
	{{range $index, $var := $block.InputVars}}{{if $var.InitialValue}}{{$initialArray := $var.GetInitialArray}}{{if $initialArray}}{{range $initialIndex, $initialValue := $initialArray}}inputs->{{$var.Name}}[{{$initialIndex}}] = {{$initialValue}};
	{{end}}{{else}}inputs->{{$var.Name}} = {{$var.InitialValue}};
	{{end}}{{end}}{{end}}
	//set any output vars with default values
	{{range $index, $var := $block.OutputVars}}{{if $var.InitialValue}}{{$initialArray := $var.GetInitialArray}}{{if $initialArray}}{{range $initialIndex, $initialValue := $initialArray}}outputs->{{$var.Name}}[{{$initialIndex}}] = {{$initialValue}};
	{{end}}{{else}}outputs->{{$var.Name}} = {{$var.InitialValue}};
	{{end}}{{end}}{{end}}

	{{if $block.Policies}}{{range $polI, $pol := $block.Policies}}
	me->_policy_{{$pol.Name}}_state = {{if $pol.States}}POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_{{(index $pol.States 0).Name}}{{else}}POLICY_STATE_{{$block.Name}}_{{$pol.Name}}_unknown{{end}};
	{{$pfbEnf := getPolicyEnfInfo $block $polI}}{{if not $pfbEnf}}//Policy is broken!{{else}}//input policy internal vars
	{{range $vari, $var := $pfbEnf.OutputPolicy.InternalVars}}
	{{$initialArray := $var.GetInitialArray}}{{if $initialArray}}{{range $initialIndex, $initialValue := $initialArray}}me->{{$var.Name}}[{{$initialIndex}}] = {{$initialValue}};
	{{end}}{{else}}me->{{$var.Name}} = {{if $var.InitialValue}}{{$var.InitialValue}}{{else}}0{{end}};
	{{end}}{{end}}{{end}}
	{{end}}{{end}}
}

void {{$block.Name}}_run_via_enforcer(enforcervars_{{$block.Name}}_t* me, inputs_{{$block.Name}}_t inputs, outputs_{{$block.Name}}_t* outputs) {
	{{if $block.Policies}}{{template "_policyIn" $block}}{{end}}

	{{$block.Name}}_run(inputs, outputs);

	{{if $block.Policies}}{{template "_policyOut" $block}}{{end}}
}{{end}}`

var cTemplateFuncMap = template.FuncMap{
	"getCECCTransitionCondition": getCECCTransitionCondition,

	"getPolicyEnfInfo": getPolicyEnfInfo,
}

var cTemplates = template.Must(template.New("").Funcs(cTemplateFuncMap).Parse(rtecTemplate))
